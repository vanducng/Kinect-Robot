CCS PCH C Compiler, Version 4.057, 4831               24-Nov-11 12:13

               Filename: RobotVision.lst

               ROM used: 10528 bytes (32%)
                         Largest free fragment is 22236
               RAM used: 210 (10%) at main() level
                         351 (17%) worst case
               Stack:    8 worst case (5 in main + 3 for interrupts)

*
0000:  GOTO   2708
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   0AB2
0058:  BTFSS  FF0.3
005A:  GOTO   0064
005E:  BTFSC  FF0.0
0060:  GOTO   0A02
0064:  BTFSS  FF0.4
0066:  GOTO   0070
006A:  BTFSC  FF0.1
006C:  GOTO   0A44
0070:  BTFSS  F9D.5
0072:  GOTO   007C
0076:  BTFSC  F9E.5
0078:  GOTO   0910
007C:  MOVFF  0F,00
0080:  MOVFF  10,01
0084:  MOVFF  11,02
0088:  MOVFF  12,03
008C:  MOVFF  13,04
0090:  BSF    0E.7
0092:  MOVFF  0D,FE9
0096:  MOVFF  08,FEA
009A:  MOVFF  09,FE1
009E:  MOVFF  0A,FE2
00A2:  MOVFF  0B,FD9
00A6:  MOVFF  0C,FDA
00AA:  MOVFF  14,FF3
00AE:  MOVFF  15,FF4
00B2:  MOVFF  16,FFA
00B6:  MOVF   05,W
00B8:  MOVFF  07,FE0
00BC:  MOVFF  06,FD8
00C0:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <STDDEF.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #FUSES NOWDT, HS, NOPUT, NOBROWNOUT, NOLVP, NOCPD, NOWRT, NODEBUG 
....................  
.................... #use delay(clock=12000000) 
.................... #use rs232 (baud=19200 , parity=n , xmit=pin_C6 , rcv=pin_C7 ,bits=8) 
.................... #byte PORTA =  0xf80 
.................... #byte PORTB =  0xf81 
.................... #byte PORTC =  0xf82 
.................... #byte PORTD =  0xf83 
.................... #byte PORTE =  0xf84 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0124:  MOVFF  13F,144
0128:  MOVFF  13E,143
012C:  MOVLB  1
012E:  MOVF   x42,F
0130:  BZ    017A
0132:  MOVFF  141,03
0136:  MOVFF  140,FE9
013A:  MOVFF  141,FEA
013E:  MOVF   FEF,F
0140:  BZ    017A
....................      *s++ = *s2++; 
0142:  MOVFF  144,03
0146:  MOVF   x43,W
0148:  INCF   x43,F
014A:  BTFSC  FD8.2
014C:  INCF   x44,F
014E:  MOVWF  x45
0150:  MOVFF  03,146
0154:  MOVFF  141,03
0158:  MOVF   x40,W
015A:  INCF   x40,F
015C:  BTFSC  FD8.2
015E:  INCF   x41,F
0160:  MOVWF  FE9
0162:  MOVFF  03,FEA
0166:  MOVFF  FEF,147
016A:  MOVFF  146,FEA
016E:  MOVFF  145,FE9
0172:  MOVFF  147,FEF
0176:  DECF   x42,F
0178:  BRA    012E
....................   for (; n > 0; n--) 
017A:  MOVF   x42,F
017C:  BZ    0196
....................      *s++ = '\0'; 
017E:  MOVFF  144,03
0182:  MOVF   x43,W
0184:  INCF   x43,F
0186:  BTFSC  FD8.2
0188:  INCF   x44,F
018A:  MOVWF  FE9
018C:  MOVFF  03,FEA
0190:  CLRF   FEF
0192:  DECF   x42,F
0194:  BRA    017A
....................  
....................   return(s1); 
0196:  MOVFF  13E,01
019A:  MOVFF  13F,02
.................... } 
019E:  MOVLB  0
01A0:  GOTO   09C2 (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
00E6:  MOVFF  13B,13D
00EA:  MOVFF  13A,13C
00EE:  MOVFF  13D,03
00F2:  MOVLB  1
00F4:  MOVFF  13C,FE9
00F8:  MOVFF  13D,FEA
00FC:  MOVF   FEF,F
00FE:  BZ    010C
0100:  INCF   x3C,F
0102:  BTFSC  FD8.2
0104:  INCF   x3D,F
0106:  MOVLB  0
0108:  BRA    00EE
010A:  MOVLB  1
....................    return(sc - s); 
010C:  MOVF   x3A,W
010E:  SUBWF  x3C,W
0110:  MOVWF  00
0112:  MOVF   x3B,W
0114:  SUBWFB x3D,W
0116:  MOVWF  03
0118:  MOVFF  00,01
011C:  MOVWF  02
.................... } 
011E:  MOVLB  0
0120:  GOTO   0994 (RETURN)
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
*
06A6:  MOVLW  7F
06A8:  MOVLB  1
06AA:  MOVWF  x3C
06AC:  CLRF   x3D
06AE:  CLRF   x3E
06B0:  CLRF   x3F
....................    float32 result = 0.0; 
06B2:  CLRF   x40
06B4:  CLRF   x41
06B6:  CLRF   x42
06B8:  CLRF   x43
....................    unsigned int8 sign = 0; 
06BA:  CLRF   x44
....................    char c; 
....................    unsigned int8 ptr = 0; 
06BC:  CLRF   x46
....................  
....................    c = s[ptr++]; 
06BE:  MOVF   x46,W
06C0:  INCF   x46,F
06C2:  CLRF   03
06C4:  ADDWF  x3A,W
06C6:  MOVWF  FE9
06C8:  MOVF   x3B,W
06CA:  ADDWFC 03,W
06CC:  MOVWF  FEA
06CE:  MOVFF  FEF,145
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
06D2:  MOVF   x45,W
06D4:  SUBLW  2F
06D6:  BC    06DE
06D8:  MOVF   x45,W
06DA:  SUBLW  39
06DC:  BC    06F2
06DE:  MOVF   x45,W
06E0:  SUBLW  2B
06E2:  BZ    06F2
06E4:  MOVF   x45,W
06E6:  SUBLW  2D
06E8:  BZ    06F2
06EA:  MOVF   x45,W
06EC:  SUBLW  2E
06EE:  BTFSS  FD8.2
06F0:  BRA    08C4
....................       if(c == '-') { 
06F2:  MOVF   x45,W
06F4:  SUBLW  2D
06F6:  BNZ   0710
....................          sign = 1; 
06F8:  MOVLW  01
06FA:  MOVWF  x44
....................          c = s[ptr++]; 
06FC:  MOVF   x46,W
06FE:  INCF   x46,F
0700:  CLRF   03
0702:  ADDWF  x3A,W
0704:  MOVWF  FE9
0706:  MOVF   x3B,W
0708:  ADDWFC 03,W
070A:  MOVWF  FEA
070C:  MOVFF  FEF,145
....................       } 
....................       if(c == '+') 
0710:  MOVF   x45,W
0712:  SUBLW  2B
0714:  BNZ   072A
....................          c = s[ptr++]; 
0716:  MOVF   x46,W
0718:  INCF   x46,F
071A:  CLRF   03
071C:  ADDWF  x3A,W
071E:  MOVWF  FE9
0720:  MOVF   x3B,W
0722:  ADDWFC 03,W
0724:  MOVWF  FEA
0726:  MOVFF  FEF,145
....................  
....................       while((c >= '0' && c <= '9')) { 
072A:  MOVF   x45,W
072C:  SUBLW  2F
072E:  BC    07F2
0730:  MOVF   x45,W
0732:  SUBLW  39
0734:  BNC   07F2
....................          result = 10*result + c - '0'; 
0736:  CLRF   x4A
0738:  CLRF   x49
073A:  MOVLW  20
073C:  MOVWF  x48
073E:  MOVLW  82
0740:  MOVWF  x47
0742:  MOVFF  143,14E
0746:  MOVFF  142,14D
074A:  MOVFF  141,14C
074E:  MOVFF  140,14B
0752:  MOVLB  0
0754:  RCALL  01A4
0756:  MOVFF  00,147
075A:  MOVFF  01,148
075E:  MOVFF  02,149
0762:  MOVFF  03,14A
0766:  MOVLB  1
0768:  CLRF   x4C
076A:  MOVFF  145,14B
076E:  MOVLB  0
0770:  RCALL  029A
0772:  BCF    FD8.1
0774:  MOVFF  14A,152
0778:  MOVFF  149,151
077C:  MOVFF  148,150
0780:  MOVFF  147,14F
0784:  MOVFF  03,156
0788:  MOVFF  02,155
078C:  MOVFF  01,154
0790:  MOVFF  00,153
0794:  RCALL  02D0
0796:  MOVFF  00,14B
079A:  MOVFF  01,14C
079E:  MOVFF  02,14D
07A2:  MOVFF  03,14E
07A6:  BSF    FD8.1
07A8:  MOVFF  03,152
07AC:  MOVFF  02,151
07B0:  MOVFF  01,150
07B4:  MOVFF  00,14F
07B8:  MOVLB  1
07BA:  CLRF   x56
07BC:  CLRF   x55
07BE:  MOVLW  40
07C0:  MOVWF  x54
07C2:  MOVLW  84
07C4:  MOVWF  x53
07C6:  MOVLB  0
07C8:  RCALL  02D0
07CA:  MOVFF  03,143
07CE:  MOVFF  02,142
07D2:  MOVFF  01,141
07D6:  MOVFF  00,140
....................          c = s[ptr++]; 
07DA:  MOVLB  1
07DC:  MOVF   x46,W
07DE:  INCF   x46,F
07E0:  CLRF   03
07E2:  ADDWF  x3A,W
07E4:  MOVWF  FE9
07E6:  MOVF   x3B,W
07E8:  ADDWFC 03,W
07EA:  MOVWF  FEA
07EC:  MOVFF  FEF,145
....................       } 
07F0:  BRA    072A
....................  
....................       if (c == '.') { 
07F2:  MOVF   x45,W
07F4:  SUBLW  2E
07F6:  BNZ   08C4
....................          c = s[ptr++]; 
07F8:  MOVF   x46,W
07FA:  INCF   x46,F
07FC:  CLRF   03
07FE:  ADDWF  x3A,W
0800:  MOVWF  FE9
0802:  MOVF   x3B,W
0804:  ADDWFC 03,W
0806:  MOVWF  FEA
0808:  MOVFF  FEF,145
....................          while((c >= '0' && c <= '9')) { 
080C:  MOVF   x45,W
080E:  SUBLW  2F
0810:  BC    08C4
0812:  MOVF   x45,W
0814:  SUBLW  39
0816:  BNC   08C4
....................              pow10 = pow10*10; 
0818:  MOVFF  13F,14A
081C:  MOVFF  13E,149
0820:  MOVFF  13D,148
0824:  MOVFF  13C,147
0828:  CLRF   x4E
082A:  CLRF   x4D
082C:  MOVLW  20
082E:  MOVWF  x4C
0830:  MOVLW  82
0832:  MOVWF  x4B
0834:  MOVLB  0
0836:  RCALL  01A4
0838:  MOVFF  03,13F
083C:  MOVFF  02,13E
0840:  MOVFF  01,13D
0844:  MOVFF  00,13C
....................              result += (c - '0')/pow10; 
0848:  MOVLW  30
084A:  MOVLB  1
084C:  SUBWF  x45,W
084E:  CLRF   x4C
0850:  MOVWF  x4B
0852:  MOVLB  0
0854:  RCALL  029A
0856:  MOVFF  03,14B
085A:  MOVFF  02,14A
085E:  MOVFF  01,149
0862:  MOVFF  00,148
0866:  MOVFF  13F,14F
086A:  MOVFF  13E,14E
086E:  MOVFF  13D,14D
0872:  MOVFF  13C,14C
0876:  RCALL  0548
0878:  BCF    FD8.1
087A:  MOVFF  143,152
087E:  MOVFF  142,151
0882:  MOVFF  141,150
0886:  MOVFF  140,14F
088A:  MOVFF  03,156
088E:  MOVFF  02,155
0892:  MOVFF  01,154
0896:  MOVFF  00,153
089A:  RCALL  02D0
089C:  MOVFF  03,143
08A0:  MOVFF  02,142
08A4:  MOVFF  01,141
08A8:  MOVFF  00,140
....................              c = s[ptr++]; 
08AC:  MOVLB  1
08AE:  MOVF   x46,W
08B0:  INCF   x46,F
08B2:  CLRF   03
08B4:  ADDWF  x3A,W
08B6:  MOVWF  FE9
08B8:  MOVF   x3B,W
08BA:  ADDWFC 03,W
08BC:  MOVWF  FEA
08BE:  MOVFF  FEF,145
....................          } 
08C2:  BRA    080C
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
08C4:  DECFSZ x44,W
08C6:  BRA    08FA
....................       result = -1*result; 
08C8:  CLRF   x4A
08CA:  CLRF   x49
08CC:  MOVLW  80
08CE:  MOVWF  x48
08D0:  MOVLW  7F
08D2:  MOVWF  x47
08D4:  MOVFF  143,14E
08D8:  MOVFF  142,14D
08DC:  MOVFF  141,14C
08E0:  MOVFF  140,14B
08E4:  MOVLB  0
08E6:  RCALL  01A4
08E8:  MOVFF  03,143
08EC:  MOVFF  02,142
08F0:  MOVFF  01,141
08F4:  MOVFF  00,140
08F8:  MOVLB  1
....................    return(result); 
08FA:  MOVFF  140,00
08FE:  MOVFF  141,01
0902:  MOVFF  142,02
0906:  MOVFF  143,03
.................... } 
090A:  MOVLB  0
090C:  GOTO   09D0 (RETURN)
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #IF !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #ENDIF 
....................  
.................... #IF defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #ENDIF 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #IF defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    int8  data1,data2; 
....................    #endif 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #IF !defined(__PCD__) 
....................      *((unsigned int8 *)(&y)) = 0x7E;  
.................... #ENDIF 
....................  
.................... #IF defined(__PCD__) // Takes care of IEEE format 
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
.................... #ENDIF 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #IF !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #ENDIF 
.................... #IF defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
.................... #ENDIF 
....................  
....................       if (n<0) 
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int8  data1,data2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................  *(((unsigned int8 *)(&y))+2) = data1; 
....................  
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................   
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
.................... { 
....................      bit_set(data1,0); 
.................... } 
....................     n = data1 - 0x7E; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int8 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................    data1--; 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(___PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int8 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................    data1--; 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
*
16E0:  MOVLW  7F
16E2:  MOVWF  xF6
16E4:  CLRF   xF7
16E6:  CLRF   xF8
16E8:  CLRF   xF9
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
16EA:  MOVLW  7E
16EC:  MOVLB  1
16EE:  MOVWF  x00
16F0:  MOVLW  80
16F2:  MOVWF  x01
16F4:  CLRF   x02
16F6:  CLRF   x03
16F8:  MOVLW  7A
16FA:  MOVWF  x04
16FC:  MOVLW  2A
16FE:  MOVWF  x05
1700:  MOVLW  AA
1702:  MOVWF  x06
1704:  MOVLW  A3
1706:  MOVWF  x07
1708:  MOVLW  75
170A:  MOVWF  x08
170C:  MOVLW  B6
170E:  MOVWF  x09
1710:  MOVLW  09
1712:  MOVWF  x0A
1714:  MOVLW  9C
1716:  MOVWF  x0B
1718:  MOVLW  6F
171A:  MOVWF  x0C
171C:  MOVLW  4F
171E:  MOVWF  x0D
1720:  MOVLW  B4
1722:  MOVWF  x0E
1724:  MOVLW  0B
1726:  MOVWF  x0F
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
1728:  MOVFF  ED,113
172C:  MOVFF  EC,112
1730:  MOVFF  EB,111
1734:  MOVFF  EA,110
1738:  CLRF   x17
173A:  CLRF   x16
173C:  CLRF   x15
173E:  CLRF   x14
1740:  MOVLB  0
1742:  RCALL  162A
1744:  BNC   174C
1746:  MOVF   xEB,W
1748:  XORLW  80
174A:  MOVWF  xEB
174C:  CLRF   18
174E:  BTFSC  FF2.7
1750:  BSF    18.7
1752:  BCF    FF2.7
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
1754:  MOVFF  ED,14B
1758:  MOVFF  EC,14A
175C:  MOVFF  EB,149
1760:  MOVFF  EA,148
1764:  MOVLW  DB
1766:  MOVLB  1
1768:  MOVWF  x4F
176A:  MOVLW  0F
176C:  MOVWF  x4E
176E:  MOVLW  49
1770:  MOVWF  x4D
1772:  MOVLW  7F
1774:  MOVWF  x4C
1776:  MOVLB  0
1778:  CALL   0548
177C:  BTFSC  18.7
177E:  BSF    FF2.7
1780:  MOVFF  03,113
1784:  MOVFF  02,112
1788:  MOVFF  01,111
178C:  MOVFF  00,110
1790:  RCALL  16A4
1792:  MOVFF  01,FA
1796:  CLRF   18
1798:  BTFSC  FF2.7
179A:  BSF    18.7
179C:  BCF    FF2.7
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
179E:  MOVFF  ED,14B
17A2:  MOVFF  EC,14A
17A6:  MOVFF  EB,149
17AA:  MOVFF  EA,148
17AE:  MOVLW  DB
17B0:  MOVLB  1
17B2:  MOVWF  x4F
17B4:  MOVLW  0F
17B6:  MOVWF  x4E
17B8:  MOVLW  49
17BA:  MOVWF  x4D
17BC:  MOVLW  7F
17BE:  MOVWF  x4C
17C0:  MOVLB  0
17C2:  CALL   0548
17C6:  BTFSC  18.7
17C8:  BSF    FF2.7
17CA:  MOVFF  00,110
17CE:  MOVFF  01,111
17D2:  MOVFF  02,112
17D6:  MOVFF  03,113
17DA:  CLRF   18
17DC:  BTFSC  FF2.7
17DE:  BSF    18.7
17E0:  BCF    FF2.7
17E2:  MOVLB  1
17E4:  CLRF   x4C
17E6:  MOVFF  FA,14B
17EA:  MOVLB  0
17EC:  CALL   029A
17F0:  BTFSC  18.7
17F2:  BSF    FF2.7
17F4:  BSF    FD8.1
17F6:  CLRF   18
17F8:  BTFSC  FF2.7
17FA:  BSF    18.7
17FC:  BCF    FF2.7
17FE:  MOVFF  113,152
1802:  MOVFF  112,151
1806:  MOVFF  111,150
180A:  MOVFF  110,14F
180E:  MOVFF  03,156
1812:  MOVFF  02,155
1816:  MOVFF  01,154
181A:  MOVFF  00,153
181E:  CALL   02D0
1822:  BTFSC  18.7
1824:  BSF    FF2.7
1826:  MOVFF  03,FF
182A:  MOVFF  02,FE
182E:  MOVFF  01,FD
1832:  MOVFF  00,FC
....................    quad = quad % 4;                    // quadrant (0 to 3) 
1836:  MOVLW  03
1838:  ANDWF  xFA,F
....................  
....................    if (quad == 0 || quad == 2) 
183A:  MOVF   xFA,F
183C:  BZ    1844
183E:  MOVF   xFA,W
1840:  SUBLW  02
1842:  BNZ   188A
1844:  CLRF   18
1846:  BTFSC  FF2.7
1848:  BSF    18.7
184A:  BCF    FF2.7
....................       t = frac * PI_DIV_BY_TWO; 
184C:  MOVFF  FF,14A
1850:  MOVFF  FE,149
1854:  MOVFF  FD,148
1858:  MOVFF  FC,147
185C:  MOVLW  DB
185E:  MOVLB  1
1860:  MOVWF  x4E
1862:  MOVLW  0F
1864:  MOVWF  x4D
1866:  MOVLW  49
1868:  MOVWF  x4C
186A:  MOVLW  7F
186C:  MOVWF  x4B
186E:  MOVLB  0
1870:  CALL   01A4
1874:  BTFSC  18.7
1876:  BSF    FF2.7
1878:  MOVFF  03,F5
187C:  MOVFF  02,F4
1880:  MOVFF  01,F3
1884:  MOVFF  00,F2
....................    else if (quad == 1) 
1888:  BRA    1998
188A:  DECFSZ xFA,W
188C:  BRA    1914
....................       t = (1-frac) * PI_DIV_BY_TWO; 
188E:  BSF    FD8.1
1890:  CLRF   18
1892:  BTFSC  FF2.7
1894:  BSF    18.7
1896:  BCF    FF2.7
1898:  MOVLB  1
189A:  CLRF   x52
189C:  CLRF   x51
189E:  CLRF   x50
18A0:  MOVLW  7F
18A2:  MOVWF  x4F
18A4:  MOVFF  FF,156
18A8:  MOVFF  FE,155
18AC:  MOVFF  FD,154
18B0:  MOVFF  FC,153
18B4:  MOVLB  0
18B6:  CALL   02D0
18BA:  BTFSC  18.7
18BC:  BSF    FF2.7
18BE:  MOVFF  00,110
18C2:  MOVFF  01,111
18C6:  MOVFF  02,112
18CA:  MOVFF  03,113
18CE:  CLRF   18
18D0:  BTFSC  FF2.7
18D2:  BSF    18.7
18D4:  BCF    FF2.7
18D6:  MOVFF  03,14A
18DA:  MOVFF  02,149
18DE:  MOVFF  01,148
18E2:  MOVFF  00,147
18E6:  MOVLW  DB
18E8:  MOVLB  1
18EA:  MOVWF  x4E
18EC:  MOVLW  0F
18EE:  MOVWF  x4D
18F0:  MOVLW  49
18F2:  MOVWF  x4C
18F4:  MOVLW  7F
18F6:  MOVWF  x4B
18F8:  MOVLB  0
18FA:  CALL   01A4
18FE:  BTFSC  18.7
1900:  BSF    FF2.7
1902:  MOVFF  03,F5
1906:  MOVFF  02,F4
190A:  MOVFF  01,F3
190E:  MOVFF  00,F2
....................    else // should be 3 
1912:  BRA    1998
....................       t = (frac-1) * PI_DIV_BY_TWO; 
1914:  BSF    FD8.1
1916:  CLRF   18
1918:  BTFSC  FF2.7
191A:  BSF    18.7
191C:  BCF    FF2.7
191E:  MOVFF  FF,152
1922:  MOVFF  FE,151
1926:  MOVFF  FD,150
192A:  MOVFF  FC,14F
192E:  MOVLB  1
1930:  CLRF   x56
1932:  CLRF   x55
1934:  CLRF   x54
1936:  MOVLW  7F
1938:  MOVWF  x53
193A:  MOVLB  0
193C:  CALL   02D0
1940:  BTFSC  18.7
1942:  BSF    FF2.7
1944:  MOVFF  00,110
1948:  MOVFF  01,111
194C:  MOVFF  02,112
1950:  MOVFF  03,113
1954:  CLRF   18
1956:  BTFSC  FF2.7
1958:  BSF    18.7
195A:  BCF    FF2.7
195C:  MOVFF  03,14A
1960:  MOVFF  02,149
1964:  MOVFF  01,148
1968:  MOVFF  00,147
196C:  MOVLW  DB
196E:  MOVLB  1
1970:  MOVWF  x4E
1972:  MOVLW  0F
1974:  MOVWF  x4D
1976:  MOVLW  49
1978:  MOVWF  x4C
197A:  MOVLW  7F
197C:  MOVWF  x4B
197E:  MOVLB  0
1980:  CALL   01A4
1984:  BTFSC  18.7
1986:  BSF    FF2.7
1988:  MOVFF  03,F5
198C:  MOVFF  02,F4
1990:  MOVFF  01,F3
1994:  MOVFF  00,F2
....................  
....................    y = 0.999999999781; 
1998:  CLRF   xF1
199A:  CLRF   xF0
199C:  CLRF   xEF
199E:  MOVLW  7F
19A0:  MOVWF  xEE
19A2:  CLRF   18
19A4:  BTFSC  FF2.7
19A6:  BSF    18.7
19A8:  BCF    FF2.7
....................    t = t * t; 
19AA:  MOVFF  F5,14A
19AE:  MOVFF  F4,149
19B2:  MOVFF  F3,148
19B6:  MOVFF  F2,147
19BA:  MOVFF  F5,14E
19BE:  MOVFF  F4,14D
19C2:  MOVFF  F3,14C
19C6:  MOVFF  F2,14B
19CA:  CALL   01A4
19CE:  BTFSC  18.7
19D0:  BSF    FF2.7
19D2:  MOVFF  03,F5
19D6:  MOVFF  02,F4
19DA:  MOVFF  01,F3
19DE:  MOVFF  00,F2
....................    for (i = 0; i <= 3; i++) 
19E2:  CLRF   xFB
19E4:  MOVF   xFB,W
19E6:  SUBLW  03
19E8:  BNC   1AD0
19EA:  CLRF   18
19EC:  BTFSC  FF2.7
19EE:  BSF    18.7
19F0:  BCF    FF2.7
....................    { 
....................       t2 = t2 * t; 
19F2:  MOVFF  F9,14A
19F6:  MOVFF  F8,149
19FA:  MOVFF  F7,148
19FE:  MOVFF  F6,147
1A02:  MOVFF  F5,14E
1A06:  MOVFF  F4,14D
1A0A:  MOVFF  F3,14C
1A0E:  MOVFF  F2,14B
1A12:  CALL   01A4
1A16:  BTFSC  18.7
1A18:  BSF    FF2.7
1A1A:  MOVFF  03,F9
1A1E:  MOVFF  02,F8
1A22:  MOVFF  01,F7
1A26:  MOVFF  00,F6
....................       y = y + p[i] * t2; 
1A2A:  MOVF   xFB,W
1A2C:  MULLW  04
1A2E:  MOVF   FF3,W
1A30:  CLRF   03
1A32:  MOVWF  FE9
1A34:  MOVLW  01
1A36:  ADDWF  03,W
1A38:  MOVWF  FEA
1A3A:  MOVFF  FEF,110
1A3E:  MOVFF  FEC,111
1A42:  MOVFF  FEC,112
1A46:  MOVFF  FEC,113
1A4A:  CLRF   18
1A4C:  BTFSC  FF2.7
1A4E:  BSF    18.7
1A50:  BCF    FF2.7
1A52:  MOVFF  113,14A
1A56:  MOVFF  112,149
1A5A:  MOVFF  111,148
1A5E:  MOVFF  110,147
1A62:  MOVFF  F9,14E
1A66:  MOVFF  F8,14D
1A6A:  MOVFF  F7,14C
1A6E:  MOVFF  F6,14B
1A72:  CALL   01A4
1A76:  BTFSC  18.7
1A78:  BSF    FF2.7
1A7A:  MOVFF  FEA,115
1A7E:  MOVFF  FE9,114
1A82:  BCF    FD8.1
1A84:  CLRF   18
1A86:  BTFSC  FF2.7
1A88:  BSF    18.7
1A8A:  BCF    FF2.7
1A8C:  MOVFF  F1,152
1A90:  MOVFF  F0,151
1A94:  MOVFF  EF,150
1A98:  MOVFF  EE,14F
1A9C:  MOVFF  03,156
1AA0:  MOVFF  02,155
1AA4:  MOVFF  01,154
1AA8:  MOVFF  00,153
1AAC:  CALL   02D0
1AB0:  BTFSC  18.7
1AB2:  BSF    FF2.7
1AB4:  MOVFF  115,FEA
1AB8:  MOVFF  114,FE9
1ABC:  MOVFF  03,F1
1AC0:  MOVFF  02,F0
1AC4:  MOVFF  01,EF
1AC8:  MOVFF  00,EE
....................    } 
1ACC:  INCF   xFB,F
1ACE:  BRA    19E4
....................  
....................    if (quad == 2 || quad == 1) 
1AD0:  MOVF   xFA,W
1AD2:  SUBLW  02
1AD4:  BZ    1ADA
1AD6:  DECFSZ xFA,W
1AD8:  BRA    1AE0
....................       y = -y;  // correct sign 
1ADA:  MOVF   xEF,W
1ADC:  XORLW  80
1ADE:  MOVWF  xEF
....................  
....................    return (y); 
1AE0:  MOVFF  EE,00
1AE4:  MOVFF  EF,01
1AE8:  MOVFF  F0,02
1AEC:  MOVFF  F1,03
.................... } 
1AF0:  RETLW  00
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[4] = { 
....................       -0.499999993585, 
....................        0.041666636258, 
....................       -0.0013888361399, 
....................        0.00002476016134 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 3; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
1AF2:  BSF    FD8.1
1AF4:  CLRF   18
1AF6:  BTFSC  FF2.7
1AF8:  BSF    18.7
1AFA:  BCF    FF2.7
1AFC:  MOVFF  E5,152
1B00:  MOVFF  E4,151
1B04:  MOVFF  E3,150
1B08:  MOVFF  E2,14F
1B0C:  MOVLW  DB
1B0E:  MOVLB  1
1B10:  MOVWF  x56
1B12:  MOVLW  0F
1B14:  MOVWF  x55
1B16:  MOVLW  49
1B18:  MOVWF  x54
1B1A:  MOVLW  7F
1B1C:  MOVWF  x53
1B1E:  MOVLB  0
1B20:  CALL   02D0
1B24:  BTFSC  18.7
1B26:  BSF    FF2.7
1B28:  MOVFF  00,E6
1B2C:  MOVFF  01,E7
1B30:  MOVFF  02,E8
1B34:  MOVFF  03,E9
1B38:  MOVFF  03,ED
1B3C:  MOVFF  02,EC
1B40:  MOVFF  01,EB
1B44:  MOVFF  00,EA
1B48:  RCALL  16E0
.................... } 
1B4A:  GOTO   1CFC (RETURN)
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #BIT DIR_RIGHT = PORTE.1   //0: forward, 1: backward 
.................... #BIT DIR_LEFT  = PORTE.2 
....................  
.................... #define time_step 50535  // 0.005 sencond  5535 // 
.................... #define PERIMETER_LEFT 31.95 
.................... #define PERIMETER_RIGHT 31.9 
.................... #define RADIUS 20.25 
.................... #define THRES_RIGHT 55 //Choose suitable Threshold to synchronize  
.................... #define THRES_LEFT 65  //two wheels speed 
.................... #define ERR 4 
.................... //Global variants 
.................... signed int32 num_Pulse_Right = 0, count_left = 0; 
.................... signed int32 num_Pulse_Left = 0; 
.................... float disTemp = 0; 
.................... int1 done_Timer1 = 0; 
....................  
.................... char  ss; 
.................... char data_receive[50] = ""; 
.................... int8 index = 0; 
....................  
.................... signed int16 pw_duty_Left = 0, pw_duty_Right = 0; 
.................... signed int32 position_Right = 0, position_Left = 0, position_set_Left = 0, position_set_Right = 0; 
....................  
.................... float Kp_r, Kd_r, Ki_r; 
.................... float Kp_l, Kd_l, Ki_l; 
.................... signed int32 e_sum_r, e_del_r, e1_r, e2_r; 
.................... signed int32 e_sum_l, e_del_l, e1_l, e2_l; 
....................  
.................... float value_cmd, anpha = 0, angle_current = 90.0, distance_move = 0; 
.................... float x_cur = 0, y_cur = 0, x_cur_old = 0, y_cur_old = 0; 
.................... char  direction_cmd, direction_cmd_old; 
.................... int1 RobotFlag = 0, RunFlag = 0, pid_Left_Flag = 0, pid_Right_Flag = 0, donePID = 0, targetFlag = 0; 
....................  
.................... void pid_Robot(); 
.................... void pid_Right(); 
.................... void pid_Left(); 
.................... void init_pid_Right(); 
.................... void init_pid_Left(); 
.................... void moveRobot(char direction, float value); 
.................... void xy_calculator(float distance); 
....................  
.................... #INT_RDA 
.................... void RDA_isr(){ 
.................... char value[20]; 
.................... ss = getc(); 
*
0910:  BTFSS  F9E.5
0912:  BRA    0910
0914:  MOVFF  FAE,30
.................... if(ss == '*')  //Beginning symbol 
0918:  MOVF   30,W
091A:  SUBLW  2A
091C:  BNZ   0956
....................    { 
....................       index = 0; 
091E:  CLRF   x63
....................       *data_receive = ""; 
0920:  CLRF   03
0922:  MOVLW  31
0924:  MOVLB  1
0926:  MOVWF  x3A
0928:  MOVFF  03,13B
092C:  CLRF   FEA
092E:  MOVWF  FE9
0930:  MOVFF  FF2,13C
0934:  BCF    FF2.7
0936:  MOVLW  00
0938:  MOVLB  0
093A:  CALL   00C2
093E:  TBLRD*-
0940:  TBLRD*+
0942:  MOVF   FF5,W
0944:  MOVWF  FEE
0946:  IORLW  00
0948:  BNZ   0940
094A:  MOVLB  1
094C:  BTFSC  x3C.7
094E:  BSF    FF2.7
....................       RunFlag = 1; 
0950:  BSF    2F.2
....................    } 
.................... else if(ss == '#') //Terminal symbol 
0952:  BRA    09FA
0954:  MOVLB  0
0956:  MOVF   30,W
0958:  SUBLW  23
095A:  BNZ   09E4
....................    { 
....................      data_receive[index++]='\0'; 
095C:  MOVF   x63,W
095E:  INCF   x63,F
0960:  CLRF   03
0962:  ADDLW  31
0964:  MOVWF  FE9
0966:  MOVLW  00
0968:  ADDWFC 03,W
096A:  MOVWF  FEA
096C:  CLRF   FEF
....................      direction_cmd = data_receive[0]; 
096E:  MOVFF  31,D0
....................     if ((direction_cmd != 'T') && direction_cmd_old == 'T' && (!donePID)) targetFlag = 1; 
0972:  MOVF   xD0,W
0974:  SUBLW  54
0976:  BZ    0982
0978:  MOVF   xD1,W
097A:  SUBLW  54
097C:  BNZ   0982
097E:  BTFSS  2F.5
0980:  BSF    2F.6
....................     direction_cmd_old = direction_cmd; 
0982:  MOVFF  D0,D1
....................     strncpy(value, data_receive + 1, strlen(data_receive) - 1); 
0986:  MOVLB  1
0988:  CLRF   x3B
098A:  MOVLW  31
098C:  MOVWF  x3A
098E:  MOVLB  0
0990:  GOTO   00E6
0994:  MOVFF  02,13B
0998:  MOVFF  01,13A
099C:  MOVLW  01
099E:  MOVLB  1
09A0:  SUBWF  01,W
09A2:  MOVWF  x3C
09A4:  MOVLW  00
09A6:  SUBWFB 02,W
09A8:  MOVWF  x3D
09AA:  MOVLW  01
09AC:  MOVWF  x3F
09AE:  MOVLW  26
09B0:  MOVWF  x3E
09B2:  CLRF   x41
09B4:  MOVLW  32
09B6:  MOVWF  x40
09B8:  MOVFF  13C,142
09BC:  MOVLB  0
09BE:  GOTO   0124
....................      value_cmd = atof(value); 
09C2:  MOVLW  01
09C4:  MOVLB  1
09C6:  MOVWF  x3B
09C8:  MOVLW  26
09CA:  MOVWF  x3A
09CC:  MOVLB  0
09CE:  BRA    06A6
09D0:  MOVFF  03,B3
09D4:  MOVFF  02,B2
09D8:  MOVFF  01,B1
09DC:  MOVFF  00,B0
....................      RobotFlag = 1; 
09E0:  BSF    2F.1
....................    } 
....................  
.................... else data_receive[index++] = ss;  
09E2:  BRA    09F8
09E4:  MOVF   x63,W
09E6:  INCF   x63,F
09E8:  CLRF   03
09EA:  ADDLW  31
09EC:  MOVWF  FE9
09EE:  MOVLW  00
09F0:  ADDWFC 03,W
09F2:  MOVWF  FEA
09F4:  MOVFF  30,FEF
09F8:  MOVLB  1
....................  
.................... } 
....................  
....................         
09FA:  BCF    F9E.5
09FC:  MOVLB  0
09FE:  GOTO   007C
.................... #INT_EXT1 //Count pulses in Right wheel 
.................... void EXT1_isr() 
.................... { 
.................... disable_interrupts(int_ext1); 
0A02:  BCF    FF0.3
.................... if(input(PIN_D1) == 1) 
0A04:  BSF    F95.1
0A06:  BTFSS  F83.1
0A08:  BRA    0A1C
....................    num_Pulse_Right++; 
0A0A:  MOVLW  01
0A0C:  ADDWF  1F,F
0A0E:  BTFSC  FD8.0
0A10:  INCF   20,F
0A12:  BTFSC  FD8.2
0A14:  INCF   21,F
0A16:  BTFSC  FD8.2
0A18:  INCF   22,F
.................... else num_Pulse_Right--; 
0A1A:  BRA    0A2C
0A1C:  MOVLW  FF
0A1E:  ADDWF  1F,F
0A20:  BTFSS  FD8.0
0A22:  ADDWF  20,F
0A24:  BTFSS  FD8.0
0A26:  ADDWF  21,F
0A28:  BTFSS  FD8.0
0A2A:  ADDWF  22,F
....................    position_Right =  num_Pulse_Right;//*360/300;  
0A2C:  MOVFF  22,6B
0A30:  MOVFF  21,6A
0A34:  MOVFF  20,69
0A38:  MOVFF  1F,68
....................     
.................... enable_interrupts(int_ext1) ; 
0A3C:  BSF    FF0.3
.................... } 
....................  
0A3E:  BCF    FF0.0
0A40:  GOTO   007C
.................... #INT_EXT2 //Count pulses in Right wheel 
.................... void EXT2_isr() 
.................... { 
.................... disable_interrupts(int_ext2); 
0A44:  BCF    FF0.4
....................    if(input(PIN_D2) == 1)  
0A46:  BSF    F95.2
0A48:  BTFSS  F83.2
0A4A:  BRA    0A74
....................    {    
....................       num_Pulse_Left++; 
0A4C:  MOVLW  01
0A4E:  ADDWF  27,F
0A50:  BTFSC  FD8.0
0A52:  INCF   28,F
0A54:  BTFSC  FD8.2
0A56:  INCF   29,F
0A58:  BTFSC  FD8.2
0A5A:  INCF   2A,F
....................       if(direction_cmd == 'T') count_left++; 
0A5C:  MOVF   xD0,W
0A5E:  SUBLW  54
0A60:  BNZ   0A72
0A62:  MOVLW  01
0A64:  ADDWF  23,F
0A66:  BTFSC  FD8.0
0A68:  INCF   24,F
0A6A:  BTFSC  FD8.2
0A6C:  INCF   25,F
0A6E:  BTFSC  FD8.2
0A70:  INCF   26,F
....................    }    
....................    else  
0A72:  BRA    0A9A
....................    { 
....................       num_Pulse_Left--; 
0A74:  MOVLW  FF
0A76:  ADDWF  27,F
0A78:  BTFSS  FD8.0
0A7A:  ADDWF  28,F
0A7C:  BTFSS  FD8.0
0A7E:  ADDWF  29,F
0A80:  BTFSS  FD8.0
0A82:  ADDWF  2A,F
....................       if(direction_cmd == 'T') count_left--; 
0A84:  MOVF   xD0,W
0A86:  SUBLW  54
0A88:  BNZ   0A9A
0A8A:  MOVLW  FF
0A8C:  ADDWF  23,F
0A8E:  BTFSS  FD8.0
0A90:  ADDWF  24,F
0A92:  BTFSS  FD8.0
0A94:  ADDWF  25,F
0A96:  BTFSS  FD8.0
0A98:  ADDWF  26,F
....................    }    
....................  
....................    position_Left =  num_Pulse_Left;//*360/300;  
0A9A:  MOVFF  2A,6F
0A9E:  MOVFF  29,6E
0AA2:  MOVFF  28,6D
0AA6:  MOVFF  27,6C
....................    
.................... enable_interrupts(int_ext2) ; 
0AAA:  BSF    FF0.4
....................  
.................... } 
....................  
....................  
0AAC:  BCF    FF0.1
0AAE:  GOTO   007C
.................... #INT_TIMER1  //Count number of pulses per time unit  
.................... void TIMER1_isr() { 
.................... //printf(lcd_putc "\ncount %ld", ++count);  
.................... // disable_interrupts(INT_TIMER1);  
....................  done_Timer1 = 1; 
0AB2:  BSF    2F.0
....................  set_timer1(time_step); 
0AB4:  MOVLW  C5
0AB6:  MOVWF  FCF
0AB8:  MOVLW  67
0ABA:  MOVWF  FCE
.................... // enable_interrupts(INT_TIMER1) ; 
....................  
.................... }   
....................  
0ABC:  BCF    F9E.0
0ABE:  GOTO   007C
.................... void main() 
.................... { 
*
2708:  CLRF   FF8
270A:  BCF    FD0.7
270C:  BSF    0D.7
270E:  CLRF   FEA
2710:  CLRF   FE9
2712:  BCF    FB8.3
2714:  MOVLW  26
2716:  MOVWF  FAF
2718:  MOVLW  A6
271A:  MOVWF  FAC
271C:  MOVLW  90
271E:  MOVWF  FAB
2720:  MOVF   FC1,W
2722:  ANDLW  C0
2724:  IORLW  0F
2726:  MOVWF  FC1
2728:  MOVLW  07
272A:  MOVWF  FB4
272C:  CLRF   19
272E:  CLRF   1A
2730:  CLRF   1F
2732:  CLRF   20
2734:  CLRF   21
2736:  CLRF   22
2738:  CLRF   23
273A:  CLRF   24
273C:  CLRF   25
273E:  CLRF   26
2740:  CLRF   27
2742:  CLRF   28
2744:  CLRF   29
2746:  CLRF   2A
2748:  CLRF   2B
274A:  CLRF   2C
274C:  CLRF   2D
274E:  CLRF   2E
2750:  BCF    2F.0
2752:  CLRF   31
2754:  CLRF   32
2756:  CLRF   33
2758:  CLRF   34
275A:  CLRF   35
275C:  CLRF   36
275E:  CLRF   37
2760:  CLRF   38
2762:  CLRF   39
2764:  CLRF   3A
2766:  CLRF   3B
2768:  CLRF   3C
276A:  CLRF   3D
276C:  CLRF   3E
276E:  CLRF   3F
2770:  CLRF   40
2772:  CLRF   41
2774:  CLRF   42
2776:  CLRF   43
2778:  CLRF   44
277A:  CLRF   45
277C:  CLRF   46
277E:  CLRF   47
2780:  CLRF   48
2782:  CLRF   49
2784:  CLRF   4A
2786:  CLRF   4B
2788:  CLRF   4C
278A:  CLRF   4D
278C:  CLRF   4E
278E:  CLRF   4F
2790:  CLRF   50
2792:  CLRF   51
2794:  CLRF   52
2796:  CLRF   53
2798:  CLRF   54
279A:  CLRF   55
279C:  CLRF   56
279E:  CLRF   57
27A0:  CLRF   58
27A2:  CLRF   59
27A4:  CLRF   5A
27A6:  CLRF   5B
27A8:  CLRF   5C
27AA:  CLRF   5D
27AC:  CLRF   5E
27AE:  CLRF   5F
27B0:  CLRF   x60
27B2:  CLRF   x61
27B4:  CLRF   x62
27B6:  CLRF   x63
27B8:  CLRF   x64
27BA:  CLRF   x65
27BC:  CLRF   x66
27BE:  CLRF   x67
27C0:  CLRF   x68
27C2:  CLRF   x69
27C4:  CLRF   x6A
27C6:  CLRF   x6B
27C8:  CLRF   x6C
27CA:  CLRF   x6D
27CC:  CLRF   x6E
27CE:  CLRF   x6F
27D0:  CLRF   x70
27D2:  CLRF   x71
27D4:  CLRF   x72
27D6:  CLRF   x73
27D8:  CLRF   x74
27DA:  CLRF   x75
27DC:  CLRF   x76
27DE:  CLRF   x77
27E0:  CLRF   xB4
27E2:  CLRF   xB5
27E4:  CLRF   xB6
27E6:  CLRF   xB7
27E8:  MOVLW  85
27EA:  MOVWF  xB8
27EC:  MOVLW  34
27EE:  MOVWF  xB9
27F0:  CLRF   xBA
27F2:  CLRF   xBB
27F4:  CLRF   xBC
27F6:  CLRF   xBD
27F8:  CLRF   xBE
27FA:  CLRF   xBF
27FC:  CLRF   xC0
27FE:  CLRF   xC1
2800:  CLRF   xC2
2802:  CLRF   xC3
2804:  CLRF   xC4
2806:  CLRF   xC5
2808:  CLRF   xC6
280A:  CLRF   xC7
280C:  CLRF   xC8
280E:  CLRF   xC9
2810:  CLRF   xCA
2812:  CLRF   xCB
2814:  CLRF   xCC
2816:  CLRF   xCD
2818:  CLRF   xCE
281A:  CLRF   xCF
281C:  BCF    2F.1
281E:  BCF    2F.2
2820:  BCF    2F.3
2822:  BCF    2F.4
2824:  BCF    2F.5
2826:  BCF    2F.6
....................  set_tris_a(0); 
2828:  MOVLW  00
282A:  MOVWF  F92
....................  set_tris_b(0xFF); 
282C:  MOVLW  FF
282E:  MOVWF  F93
....................  set_tris_e(0); 
2830:  BCF    F96.0
2832:  BCF    F96.1
2834:  BCF    F96.2
....................  set_tris_c(0x80); 
2836:  MOVLW  80
2838:  MOVWF  F94
....................  set_tris_d(0x0F); 
283A:  MOVLW  0F
283C:  MOVWF  F95
....................  DIR_RIGHT = 0;  //right wheel forward 
283E:  BCF    F84.1
....................  DIR_LEFT = 0; 
2840:  BCF    F84.2
....................  /* 
....................  lcd_init(); 
....................  lcd_putc("Test"); 
....................  lcd_gotoxy(1,2); 
....................  lcd_putc("Dong Co"); 
....................  delay_ms(2000); */ 
....................      
....................  setup_adc_ports(NO_ANALOGS); 
2842:  MOVF   FC1,W
2844:  ANDLW  C0
2846:  IORLW  0F
2848:  MOVWF  FC1
....................  setup_timer_1(T1_INTERNAL | T1_DIV_BY_1 ); 
284A:  MOVLW  85
284C:  MOVWF  FCD
....................  set_timer1(time_step);   
284E:  MOVLW  C5
2850:  MOVWF  FCF
2852:  MOVLW  67
2854:  MOVWF  FCE
....................  setup_timer_2(T2_DIV_BY_4,255,1);  //f_pwm = 2.9 Khz, T_pwm = 4.(PR2+1).Tosc.Pre-scale 
2856:  MOVLW  00
2858:  IORLW  05
285A:  MOVWF  FCA
285C:  MOVLW  FF
285E:  MOVWF  FCB
....................  output_low(PIN_C1); // Set CCP2 output low  
2860:  BCF    F94.1
2862:  BCF    F8B.1
....................  output_low(PIN_C2); // Set CCP1 output low  
2864:  BCF    F94.2
2866:  BCF    F8B.2
....................  
....................  setup_ccp1(CCP_PWM);    //khoi tao bo PWM1 
2868:  BCF    F94.2
286A:  BCF    F8B.2
286C:  MOVLW  0C
286E:  MOVWF  FBD
2870:  CLRF   FB7
....................  setup_ccp2(CCP_PWM);    //khoi tao bo PWM2 
2872:  BCF    F94.1
2874:  BCF    F8B.1
2876:  MOVWF  FBA
....................  set_pwm1_duty(0);      //PIN_C2, Right motor 
2878:  CLRF   FBE
....................  set_pwm2_duty(0);      //PIN_C1, Left motor 
287A:  CLRF   FBB
....................   
....................  enable_interrupts(INT_RDA);  
287C:  BSF    F9D.5
....................  enable_interrupts(int_ext1); 
287E:  BSF    FF0.3
....................  enable_interrupts(int_ext2); 
2880:  BSF    FF0.4
....................  ext_int_edge(1, H_TO_L ); 
2882:  BCF    FF1.5
....................  ext_int_edge(2, H_TO_L ); 
2884:  BCF    FF1.4
....................  enable_interrupts(INT_TIMER1);    
2886:  BSF    F9D.0
....................  enable_interrupts(GLOBAL);    
2888:  MOVLW  C0
288A:  IORWF  FF2,F
....................       
....................  printf("X%.3fY%.3fA%.3fN", x_cur, y_cur, angle_current); 
288C:  MOVLW  58
288E:  BTFSS  F9E.4
2890:  BRA    288E
2892:  MOVWF  FAD
2894:  MOVLW  89
2896:  MOVWF  FE9
2898:  MOVFF  C3,D5
289C:  MOVFF  C2,D4
28A0:  MOVFF  C1,D3
28A4:  MOVFF  C0,D2
28A8:  MOVLW  03
28AA:  MOVWF  xD6
28AC:  CALL   0B7A
28B0:  MOVLW  59
28B2:  BTFSS  F9E.4
28B4:  BRA    28B2
28B6:  MOVWF  FAD
28B8:  MOVLW  89
28BA:  MOVWF  FE9
28BC:  MOVFF  C7,D5
28C0:  MOVFF  C6,D4
28C4:  MOVFF  C5,D3
28C8:  MOVFF  C4,D2
28CC:  MOVLW  03
28CE:  MOVWF  xD6
28D0:  CALL   0B7A
28D4:  MOVLW  41
28D6:  BTFSS  F9E.4
28D8:  BRA    28D6
28DA:  MOVWF  FAD
28DC:  MOVLW  89
28DE:  MOVWF  FE9
28E0:  MOVFF  BB,D5
28E4:  MOVFF  BA,D4
28E8:  MOVFF  B9,D3
28EC:  MOVFF  B8,D2
28F0:  MOVLW  03
28F2:  MOVWF  xD6
28F4:  CALL   0B7A
28F8:  MOVLW  4E
28FA:  BTFSS  F9E.4
28FC:  BRA    28FA
28FE:  MOVWF  FAD
....................  while(true) 
....................  { 
....................   if(done_Timer1) 
2900:  BTFSS  2F.0
2902:  BRA    2920
....................    { 
....................       moveRobot(direction_cmd, value_cmd); 
2904:  MOVFF  D0,D2
2908:  MOVFF  B3,D6
290C:  MOVFF  B2,D5
2910:  MOVFF  B1,D4
2914:  MOVFF  B0,D3
2918:  GOTO   0DAE
....................       pid_Robot(); 
291C:  BRA    224A
....................       done_Timer1 = 0; 
291E:  BCF    2F.0
....................     } 
.................... } 
2920:  BRA    2900
.................... } 
.................... void xy_calculator(float distance) 
.................... { 
*
1B4E:  CLRF   18
1B50:  BTFSC  FF2.7
1B52:  BSF    18.7
1B54:  BCF    FF2.7
*
2922:  SLEEP 
....................    x_cur = x_cur_old + distance*cos(angle_current*PI/180.0); 
*
1B56:  MOVFF  BB,14A
1B5A:  MOVFF  BA,149
1B5E:  MOVFF  B9,148
1B62:  MOVFF  B8,147
1B66:  MOVLW  DB
1B68:  MOVLB  1
1B6A:  MOVWF  x4E
1B6C:  MOVLW  0F
1B6E:  MOVWF  x4D
1B70:  MOVLW  49
1B72:  MOVWF  x4C
1B74:  MOVLW  80
1B76:  MOVWF  x4B
1B78:  MOVLB  0
1B7A:  CALL   01A4
1B7E:  BTFSC  18.7
1B80:  BSF    FF2.7
1B82:  MOVFF  00,DA
1B86:  MOVFF  01,DB
1B8A:  MOVFF  02,DC
1B8E:  MOVFF  03,DD
1B92:  CLRF   18
1B94:  BTFSC  FF2.7
1B96:  BSF    18.7
1B98:  BCF    FF2.7
1B9A:  MOVFF  03,14B
1B9E:  MOVFF  02,14A
1BA2:  MOVFF  01,149
1BA6:  MOVFF  00,148
1BAA:  MOVLB  1
1BAC:  CLRF   x4F
1BAE:  CLRF   x4E
1BB0:  MOVLW  34
1BB2:  MOVWF  x4D
1BB4:  MOVLW  86
1BB6:  MOVWF  x4C
1BB8:  MOVLB  0
1BBA:  CALL   0548
1BBE:  BTFSC  18.7
1BC0:  BSF    FF2.7
1BC2:  MOVFF  00,DE
1BC6:  MOVFF  01,DF
1BCA:  MOVFF  02,E0
1BCE:  MOVFF  03,E1
1BD2:  MOVFF  03,ED
1BD6:  MOVFF  02,EC
1BDA:  MOVFF  01,EB
1BDE:  MOVFF  00,EA
1BE2:  RCALL  16E0
1BE4:  CLRF   18
1BE6:  BTFSC  FF2.7
1BE8:  BSF    18.7
1BEA:  BCF    FF2.7
1BEC:  MOVFF  D9,14A
1BF0:  MOVFF  D8,149
1BF4:  MOVFF  D7,148
1BF8:  MOVFF  D6,147
1BFC:  MOVFF  03,14E
1C00:  MOVFF  02,14D
1C04:  MOVFF  01,14C
1C08:  MOVFF  00,14B
1C0C:  CALL   01A4
1C10:  BTFSC  18.7
1C12:  BSF    FF2.7
1C14:  MOVFF  FEA,E0
1C18:  MOVFF  FE9,DF
1C1C:  BCF    FD8.1
1C1E:  CLRF   18
1C20:  BTFSC  FF2.7
1C22:  BSF    18.7
1C24:  BCF    FF2.7
1C26:  MOVFF  CB,152
1C2A:  MOVFF  CA,151
1C2E:  MOVFF  C9,150
1C32:  MOVFF  C8,14F
1C36:  MOVFF  03,156
1C3A:  MOVFF  02,155
1C3E:  MOVFF  01,154
1C42:  MOVFF  00,153
1C46:  CALL   02D0
1C4A:  BTFSC  18.7
1C4C:  BSF    FF2.7
1C4E:  MOVFF  E0,FEA
1C52:  MOVFF  DF,FE9
1C56:  MOVFF  03,C3
1C5A:  MOVFF  02,C2
1C5E:  MOVFF  01,C1
1C62:  MOVFF  00,C0
1C66:  CLRF   18
1C68:  BTFSC  FF2.7
1C6A:  BSF    18.7
1C6C:  BCF    FF2.7
....................    y_cur = y_cur_old + distance*sin(angle_current*PI/180.0); 
1C6E:  MOVFF  BB,14A
1C72:  MOVFF  BA,149
1C76:  MOVFF  B9,148
1C7A:  MOVFF  B8,147
1C7E:  MOVLW  DB
1C80:  MOVLB  1
1C82:  MOVWF  x4E
1C84:  MOVLW  0F
1C86:  MOVWF  x4D
1C88:  MOVLW  49
1C8A:  MOVWF  x4C
1C8C:  MOVLW  80
1C8E:  MOVWF  x4B
1C90:  MOVLB  0
1C92:  CALL   01A4
1C96:  BTFSC  18.7
1C98:  BSF    FF2.7
1C9A:  MOVFF  00,DA
1C9E:  MOVFF  01,DB
1CA2:  MOVFF  02,DC
1CA6:  MOVFF  03,DD
1CAA:  CLRF   18
1CAC:  BTFSC  FF2.7
1CAE:  BSF    18.7
1CB0:  BCF    FF2.7
1CB2:  MOVFF  03,14B
1CB6:  MOVFF  02,14A
1CBA:  MOVFF  01,149
1CBE:  MOVFF  00,148
1CC2:  MOVLB  1
1CC4:  CLRF   x4F
1CC6:  CLRF   x4E
1CC8:  MOVLW  34
1CCA:  MOVWF  x4D
1CCC:  MOVLW  86
1CCE:  MOVWF  x4C
1CD0:  MOVLB  0
1CD2:  CALL   0548
1CD6:  BTFSC  18.7
1CD8:  BSF    FF2.7
1CDA:  MOVFF  00,DE
1CDE:  MOVFF  01,DF
1CE2:  MOVFF  02,E0
1CE6:  MOVFF  03,E1
1CEA:  MOVFF  03,E5
1CEE:  MOVFF  02,E4
1CF2:  MOVFF  01,E3
1CF6:  MOVFF  00,E2
1CFA:  BRA    1AF2
1CFC:  CLRF   18
1CFE:  BTFSC  FF2.7
1D00:  BSF    18.7
1D02:  BCF    FF2.7
1D04:  MOVFF  D9,14A
1D08:  MOVFF  D8,149
1D0C:  MOVFF  D7,148
1D10:  MOVFF  D6,147
1D14:  MOVFF  03,14E
1D18:  MOVFF  02,14D
1D1C:  MOVFF  01,14C
1D20:  MOVFF  00,14B
1D24:  CALL   01A4
1D28:  BTFSC  18.7
1D2A:  BSF    FF2.7
1D2C:  MOVFF  FEA,E0
1D30:  MOVFF  FE9,DF
1D34:  BCF    FD8.1
1D36:  CLRF   18
1D38:  BTFSC  FF2.7
1D3A:  BSF    18.7
1D3C:  BCF    FF2.7
1D3E:  MOVFF  CF,152
1D42:  MOVFF  CE,151
1D46:  MOVFF  CD,150
1D4A:  MOVFF  CC,14F
1D4E:  MOVFF  03,156
1D52:  MOVFF  02,155
1D56:  MOVFF  01,154
1D5A:  MOVFF  00,153
1D5E:  CALL   02D0
1D62:  BTFSC  18.7
1D64:  BSF    FF2.7
1D66:  MOVFF  E0,FEA
1D6A:  MOVFF  DF,FE9
1D6E:  MOVFF  03,C7
1D72:  MOVFF  02,C6
1D76:  MOVFF  01,C5
1D7A:  MOVFF  00,C4
....................    x_cur_old = x_cur; 
1D7E:  MOVFF  C3,CB
1D82:  MOVFF  C2,CA
1D86:  MOVFF  C1,C9
1D8A:  MOVFF  C0,C8
....................    y_cur_old = y_cur;       
1D8E:  MOVFF  C7,CF
1D92:  MOVFF  C6,CE
1D96:  MOVFF  C5,CD
1D9A:  MOVFF  C4,CC
.................... } 
1D9E:  RETLW  00
....................  
.................... void pid_Robot() 
.................... { 
....................     if(targetFlag) 
*
224A:  BTFSS  2F.6
224C:  BRA    237E
....................    { 
....................     distance_move = PERIMETER_LEFT*count_left/300.0; 
224E:  MOVFF  26,DD
2252:  MOVFF  25,DC
2256:  MOVFF  24,DB
225A:  MOVFF  23,DA
225E:  CALL   15D4
2262:  CLRF   18
2264:  BTFSC  FF2.7
2266:  BSF    18.7
2268:  BCF    FF2.7
226A:  MOVLW  9A
226C:  MOVLB  1
226E:  MOVWF  x4A
2270:  MOVLW  99
2272:  MOVWF  x49
2274:  MOVLW  7F
2276:  MOVWF  x48
2278:  MOVLW  83
227A:  MOVWF  x47
227C:  MOVFF  03,14E
2280:  MOVFF  02,14D
2284:  MOVFF  01,14C
2288:  MOVFF  00,14B
228C:  MOVLB  0
228E:  CALL   01A4
2292:  BTFSC  18.7
2294:  BSF    FF2.7
2296:  MOVFF  00,D2
229A:  MOVFF  01,D3
229E:  MOVFF  02,D4
22A2:  MOVFF  03,D5
22A6:  CLRF   18
22A8:  BTFSC  FF2.7
22AA:  BSF    18.7
22AC:  BCF    FF2.7
22AE:  MOVFF  03,14B
22B2:  MOVFF  02,14A
22B6:  MOVFF  01,149
22BA:  MOVFF  00,148
22BE:  MOVLB  1
22C0:  CLRF   x4F
22C2:  CLRF   x4E
22C4:  MOVLW  16
22C6:  MOVWF  x4D
22C8:  MOVLW  87
22CA:  MOVWF  x4C
22CC:  MOVLB  0
22CE:  CALL   0548
22D2:  BTFSC  18.7
22D4:  BSF    FF2.7
22D6:  MOVFF  03,BF
22DA:  MOVFF  02,BE
22DE:  MOVFF  01,BD
22E2:  MOVFF  00,BC
....................     xy_calculator(distance_move); 
22E6:  MOVFF  BF,D9
22EA:  MOVFF  BE,D8
22EE:  MOVFF  BD,D7
22F2:  MOVFF  BC,D6
22F6:  RCALL  1B4E
....................     count_left = 0; 
22F8:  CLRF   26
22FA:  CLRF   25
22FC:  CLRF   24
22FE:  CLRF   23
....................     distance_move = 0; 
2300:  CLRF   xBF
2302:  CLRF   xBE
2304:  CLRF   xBD
2306:  CLRF   xBC
....................     printf("X%.3fY%.3fA%.3fT", x_cur, y_cur, angle_current); 
2308:  MOVLW  58
230A:  BTFSS  F9E.4
230C:  BRA    230A
230E:  MOVWF  FAD
2310:  MOVLW  89
2312:  MOVWF  FE9
2314:  MOVFF  C3,D5
2318:  MOVFF  C2,D4
231C:  MOVFF  C1,D3
2320:  MOVFF  C0,D2
2324:  MOVLW  03
2326:  MOVWF  xD6
2328:  CALL   0B7A
232C:  MOVLW  59
232E:  BTFSS  F9E.4
2330:  BRA    232E
2332:  MOVWF  FAD
2334:  MOVLW  89
2336:  MOVWF  FE9
2338:  MOVFF  C7,D5
233C:  MOVFF  C6,D4
2340:  MOVFF  C5,D3
2344:  MOVFF  C4,D2
2348:  MOVLW  03
234A:  MOVWF  xD6
234C:  CALL   0B7A
2350:  MOVLW  41
2352:  BTFSS  F9E.4
2354:  BRA    2352
2356:  MOVWF  FAD
2358:  MOVLW  89
235A:  MOVWF  FE9
235C:  MOVFF  BB,D5
2360:  MOVFF  BA,D4
2364:  MOVFF  B9,D3
2368:  MOVFF  B8,D2
236C:  MOVLW  03
236E:  MOVWF  xD6
2370:  CALL   0B7A
2374:  MOVLW  54
2376:  BTFSS  F9E.4
2378:  BRA    2376
237A:  MOVWF  FAD
....................     targetFlag = 0; 
237C:  BCF    2F.6
....................    }  
....................    if(direction_cmd == 'T' ) // send distance every 0.75 second 
237E:  MOVF   xD0,W
2380:  SUBLW  54
2382:  BNZ   2448
....................    { 
....................       disTemp = PERIMETER_LEFT*count_left/300.0; 
2384:  MOVFF  26,DD
2388:  MOVFF  25,DC
238C:  MOVFF  24,DB
2390:  MOVFF  23,DA
2394:  CALL   15D4
2398:  CLRF   18
239A:  BTFSC  FF2.7
239C:  BSF    18.7
239E:  BCF    FF2.7
23A0:  MOVLW  9A
23A2:  MOVLB  1
23A4:  MOVWF  x4A
23A6:  MOVLW  99
23A8:  MOVWF  x49
23AA:  MOVLW  7F
23AC:  MOVWF  x48
23AE:  MOVLW  83
23B0:  MOVWF  x47
23B2:  MOVFF  03,14E
23B6:  MOVFF  02,14D
23BA:  MOVFF  01,14C
23BE:  MOVFF  00,14B
23C2:  MOVLB  0
23C4:  CALL   01A4
23C8:  BTFSC  18.7
23CA:  BSF    FF2.7
23CC:  MOVFF  00,D2
23D0:  MOVFF  01,D3
23D4:  MOVFF  02,D4
23D8:  MOVFF  03,D5
23DC:  CLRF   18
23DE:  BTFSC  FF2.7
23E0:  BSF    18.7
23E2:  BCF    FF2.7
23E4:  MOVFF  03,14B
23E8:  MOVFF  02,14A
23EC:  MOVFF  01,149
23F0:  MOVFF  00,148
23F4:  MOVLB  1
23F6:  CLRF   x4F
23F8:  CLRF   x4E
23FA:  MOVLW  16
23FC:  MOVWF  x4D
23FE:  MOVLW  87
2400:  MOVWF  x4C
2402:  MOVLB  0
2404:  CALL   0548
2408:  BTFSC  18.7
240A:  BSF    FF2.7
240C:  MOVFF  03,2E
2410:  MOVFF  02,2D
2414:  MOVFF  01,2C
2418:  MOVFF  00,2B
....................       printf("X%.3fD", disTemp);       
241C:  MOVLW  58
241E:  BTFSS  F9E.4
2420:  BRA    241E
2422:  MOVWF  FAD
2424:  MOVLW  89
2426:  MOVWF  FE9
2428:  MOVFF  2E,D5
242C:  MOVFF  2D,D4
2430:  MOVFF  2C,D3
2434:  MOVFF  2B,D2
2438:  MOVLW  03
243A:  MOVWF  xD6
243C:  CALL   0B7A
2440:  MOVLW  44
2442:  BTFSS  F9E.4
2444:  BRA    2442
2446:  MOVWF  FAD
....................    } 
....................     
....................     pid_Right(); 
2448:  BRA    1DA0
....................     pid_Left(); 
244A:  BRA    1FF4
....................  
....................  if ((!pid_Left_Flag) && (!pid_Right_Flag) && (!donePID)) 
244C:  BTFSC  2F.3
244E:  BRA    2704
2450:  BTFSC  2F.4
2452:  BRA    2704
2454:  BTFSC  2F.5
2456:  BRA    2704
....................    { 
....................       if(direction_cmd == 'R')  
2458:  MOVF   xD0,W
245A:  SUBLW  52
245C:  BNZ   24C4
....................        { 
....................         angle_current  -= value_cmd; 
245E:  BSF    FD8.1
2460:  CLRF   18
2462:  BTFSC  FF2.7
2464:  BSF    18.7
2466:  BCF    FF2.7
2468:  MOVFF  BB,152
246C:  MOVFF  BA,151
2470:  MOVFF  B9,150
2474:  MOVFF  B8,14F
2478:  MOVFF  B3,156
247C:  MOVFF  B2,155
2480:  MOVFF  B1,154
2484:  MOVFF  B0,153
2488:  CALL   02D0
248C:  BTFSC  18.7
248E:  BSF    FF2.7
2490:  MOVFF  03,BB
2494:  MOVFF  02,BA
2498:  MOVFF  01,B9
249C:  MOVFF  00,B8
....................         direction_cmd = ""; 
24A0:  CLRF   FEA
24A2:  MOVLW  D0
24A4:  MOVWF  FE9
24A6:  MOVFF  FF2,D2
24AA:  BCF    FF2.7
24AC:  MOVLW  00
24AE:  CALL   00C2
24B2:  TBLRD*-
24B4:  TBLRD*+
24B6:  MOVF   FF5,W
24B8:  MOVWF  FEE
24BA:  IORLW  00
24BC:  BNZ   24B4
24BE:  BTFSC  xD2.7
24C0:  BSF    FF2.7
....................        } 
....................      else if(direction_cmd == 'L') 
24C2:  BRA    25C0
24C4:  MOVF   xD0,W
24C6:  SUBLW  4C
24C8:  BNZ   2530
....................       { 
....................       angle_current  += value_cmd; 
24CA:  BCF    FD8.1
24CC:  CLRF   18
24CE:  BTFSC  FF2.7
24D0:  BSF    18.7
24D2:  BCF    FF2.7
24D4:  MOVFF  BB,152
24D8:  MOVFF  BA,151
24DC:  MOVFF  B9,150
24E0:  MOVFF  B8,14F
24E4:  MOVFF  B3,156
24E8:  MOVFF  B2,155
24EC:  MOVFF  B1,154
24F0:  MOVFF  B0,153
24F4:  CALL   02D0
24F8:  BTFSC  18.7
24FA:  BSF    FF2.7
24FC:  MOVFF  03,BB
2500:  MOVFF  02,BA
2504:  MOVFF  01,B9
2508:  MOVFF  00,B8
....................       direction_cmd = ""; 
250C:  CLRF   FEA
250E:  MOVLW  D0
2510:  MOVWF  FE9
2512:  MOVFF  FF2,D2
2516:  BCF    FF2.7
2518:  MOVLW  00
251A:  CALL   00C2
251E:  TBLRD*-
2520:  TBLRD*+
2522:  MOVF   FF5,W
2524:  MOVWF  FEE
2526:  IORLW  00
2528:  BNZ   2520
252A:  BTFSC  xD2.7
252C:  BSF    FF2.7
....................       } 
....................       else if (direction_cmd == 'F' || direction_cmd == 'T') 
252E:  BRA    25C0
2530:  MOVF   xD0,W
2532:  SUBLW  46
2534:  BZ    253C
2536:  MOVF   xD0,W
2538:  SUBLW  54
253A:  BNZ   2574
....................        { 
....................          xy_calculator(value_cmd); 
253C:  MOVFF  B3,D9
2540:  MOVFF  B2,D8
2544:  MOVFF  B1,D7
2548:  MOVFF  B0,D6
254C:  CALL   1B4E
....................          direction_cmd = ""; 
2550:  CLRF   FEA
2552:  MOVLW  D0
2554:  MOVWF  FE9
2556:  MOVFF  FF2,D2
255A:  BCF    FF2.7
255C:  MOVLW  00
255E:  CALL   00C2
2562:  TBLRD*-
2564:  TBLRD*+
2566:  MOVF   FF5,W
2568:  MOVWF  FEE
256A:  IORLW  00
256C:  BNZ   2564
256E:  BTFSC  xD2.7
2570:  BSF    FF2.7
....................        } 
....................      else if (direction_cmd == 'B') 
2572:  BRA    25C0
2574:  MOVF   xD0,W
2576:  SUBLW  42
2578:  BNZ   25C0
....................       { 
....................          xy_calculator(-value_cmd); 
257A:  MOVFF  B0,D2
257E:  MOVF   xB1,W
2580:  XORLW  80
2582:  MOVWF  xD3
2584:  MOVFF  B2,D4
2588:  MOVFF  B3,D5
258C:  MOVFF  B3,D9
2590:  MOVFF  B2,D8
2594:  MOVWF  xD7
2596:  MOVFF  B0,D6
259A:  CALL   1B4E
....................          direction_cmd = ""; 
259E:  CLRF   FEA
25A0:  MOVLW  D0
25A2:  MOVWF  FE9
25A4:  MOVFF  FF2,D2
25A8:  BCF    FF2.7
25AA:  MOVLW  00
25AC:  CALL   00C2
25B0:  TBLRD*-
25B2:  TBLRD*+
25B4:  MOVF   FF5,W
25B6:  MOVWF  FEE
25B8:  IORLW  00
25BA:  BNZ   25B2
25BC:  BTFSC  xD2.7
25BE:  BSF    FF2.7
....................       } 
....................  
....................  
....................     if (angle_current >= 360.0) angle_current -= 360.0; 
25C0:  MOVLB  1
25C2:  CLRF   x13
25C4:  CLRF   x12
25C6:  MOVLW  34
25C8:  MOVWF  x11
25CA:  MOVLW  87
25CC:  MOVWF  x10
25CE:  MOVFF  BB,117
25D2:  MOVFF  BA,116
25D6:  MOVFF  B9,115
25DA:  MOVFF  B8,114
25DE:  MOVLB  0
25E0:  CALL   162A
25E4:  BC    25E8
25E6:  BNZ   262A
25E8:  BSF    FD8.1
25EA:  CLRF   18
25EC:  BTFSC  FF2.7
25EE:  BSF    18.7
25F0:  BCF    FF2.7
25F2:  MOVFF  BB,152
25F6:  MOVFF  BA,151
25FA:  MOVFF  B9,150
25FE:  MOVFF  B8,14F
2602:  MOVLB  1
2604:  CLRF   x56
2606:  CLRF   x55
2608:  MOVLW  34
260A:  MOVWF  x54
260C:  MOVLW  87
260E:  MOVWF  x53
2610:  MOVLB  0
2612:  CALL   02D0
2616:  BTFSC  18.7
2618:  BSF    FF2.7
261A:  MOVFF  03,BB
261E:  MOVFF  02,BA
2622:  MOVFF  01,B9
2626:  MOVFF  00,B8
....................     if (angle_current < 0 ) angle_current += 360.0; 
262A:  MOVFF  BB,113
262E:  MOVFF  BA,112
2632:  MOVFF  B9,111
2636:  MOVFF  B8,110
263A:  MOVLB  1
263C:  CLRF   x17
263E:  CLRF   x16
2640:  CLRF   x15
2642:  CLRF   x14
2644:  MOVLB  0
2646:  CALL   162A
264A:  BNC   268E
264C:  BCF    FD8.1
264E:  CLRF   18
2650:  BTFSC  FF2.7
2652:  BSF    18.7
2654:  BCF    FF2.7
2656:  MOVFF  BB,152
265A:  MOVFF  BA,151
265E:  MOVFF  B9,150
2662:  MOVFF  B8,14F
2666:  MOVLB  1
2668:  CLRF   x56
266A:  CLRF   x55
266C:  MOVLW  34
266E:  MOVWF  x54
2670:  MOVLW  87
2672:  MOVWF  x53
2674:  MOVLB  0
2676:  CALL   02D0
267A:  BTFSC  18.7
267C:  BSF    FF2.7
267E:  MOVFF  03,BB
2682:  MOVFF  02,BA
2686:  MOVFF  01,B9
268A:  MOVFF  00,B8
....................           
....................    printf("X%.3fY%.3fA%.3fN", x_cur, y_cur, angle_current); 
268E:  MOVLW  58
2690:  BTFSS  F9E.4
2692:  BRA    2690
2694:  MOVWF  FAD
2696:  MOVLW  89
2698:  MOVWF  FE9
269A:  MOVFF  C3,D5
269E:  MOVFF  C2,D4
26A2:  MOVFF  C1,D3
26A6:  MOVFF  C0,D2
26AA:  MOVLW  03
26AC:  MOVWF  xD6
26AE:  CALL   0B7A
26B2:  MOVLW  59
26B4:  BTFSS  F9E.4
26B6:  BRA    26B4
26B8:  MOVWF  FAD
26BA:  MOVLW  89
26BC:  MOVWF  FE9
26BE:  MOVFF  C7,D5
26C2:  MOVFF  C6,D4
26C6:  MOVFF  C5,D3
26CA:  MOVFF  C4,D2
26CE:  MOVLW  03
26D0:  MOVWF  xD6
26D2:  CALL   0B7A
26D6:  MOVLW  41
26D8:  BTFSS  F9E.4
26DA:  BRA    26D8
26DC:  MOVWF  FAD
26DE:  MOVLW  89
26E0:  MOVWF  FE9
26E2:  MOVFF  BB,D5
26E6:  MOVFF  BA,D4
26EA:  MOVFF  B9,D3
26EE:  MOVFF  B8,D2
26F2:  MOVLW  03
26F4:  MOVWF  xD6
26F6:  CALL   0B7A
26FA:  MOVLW  4E
26FC:  BTFSS  F9E.4
26FE:  BRA    26FC
2700:  MOVWF  FAD
....................     donePID = 1;    
2702:  BSF    2F.5
....................    }  
.................... } 
2704:  GOTO   291E (RETURN)
.................... void init_pid_Right() 
.................... { 
.................... Kp_r = 2.5; 
*
0D12:  CLRF   x7B
0D14:  CLRF   x7A
0D16:  MOVLW  20
0D18:  MOVWF  x79
0D1A:  MOVLW  80
0D1C:  MOVWF  x78
.................... ki_r = 0.0000001; 
0D1E:  MOVLW  95
0D20:  MOVWF  x83
0D22:  MOVLW  BF
0D24:  MOVWF  x82
0D26:  MOVLW  56
0D28:  MOVWF  x81
0D2A:  MOVLW  67
0D2C:  MOVWF  x80
.................... kd_r = 2.0; 
0D2E:  CLRF   x7F
0D30:  CLRF   x7E
0D32:  CLRF   x7D
0D34:  MOVLW  80
0D36:  MOVWF  x7C
.................... e_sum_r = 0; 
0D38:  CLRF   x93
0D3A:  CLRF   x92
0D3C:  CLRF   x91
0D3E:  CLRF   x90
.................... e_del_r = 0; 
0D40:  CLRF   x97
0D42:  CLRF   x96
0D44:  CLRF   x95
0D46:  CLRF   x94
.................... e1_r = 0; 
0D48:  CLRF   x9B
0D4A:  CLRF   x9A
0D4C:  CLRF   x99
0D4E:  CLRF   x98
.................... e2_r = 0; 
0D50:  CLRF   x9F
0D52:  CLRF   x9E
0D54:  CLRF   x9D
0D56:  CLRF   x9C
.................... pw_duty_Right = 0; 
0D58:  CLRF   x67
0D5A:  CLRF   x66
.................... } 
0D5C:  GOTO   0DB6 (RETURN)
....................  
.................... void init_pid_Left() 
.................... { 
.................... Kp_l = 2.5;  //0.9 
0D60:  CLRF   x87
0D62:  CLRF   x86
0D64:  MOVLW  20
0D66:  MOVWF  x85
0D68:  MOVLW  80
0D6A:  MOVWF  x84
.................... ki_l = 0.0000001; 
0D6C:  MOVLW  95
0D6E:  MOVWF  x8F
0D70:  MOVLW  BF
0D72:  MOVWF  x8E
0D74:  MOVLW  56
0D76:  MOVWF  x8D
0D78:  MOVLW  67
0D7A:  MOVWF  x8C
.................... kd_l =2.0;      //1 
0D7C:  CLRF   x8B
0D7E:  CLRF   x8A
0D80:  CLRF   x89
0D82:  MOVLW  80
0D84:  MOVWF  x88
.................... e_sum_l = 0; 
0D86:  CLRF   xA3
0D88:  CLRF   xA2
0D8A:  CLRF   xA1
0D8C:  CLRF   xA0
.................... e_del_l = 0; 
0D8E:  CLRF   xA7
0D90:  CLRF   xA6
0D92:  CLRF   xA5
0D94:  CLRF   xA4
.................... e1_l = 0; 
0D96:  CLRF   xAB
0D98:  CLRF   xAA
0D9A:  CLRF   xA9
0D9C:  CLRF   xA8
.................... e2_l = 0; 
0D9E:  CLRF   xAF
0DA0:  CLRF   xAE
0DA2:  CLRF   xAD
0DA4:  CLRF   xAC
.................... pw_duty_Left = 0; 
0DA6:  CLRF   x65
0DA8:  CLRF   x64
.................... } 
0DAA:  GOTO   0DB8 (RETURN)
....................  
.................... void pid_Right() 
.................... { 
....................   signed int16 temp_kp = 0; 
*
1DA0:  CLRF   xD2
1DA2:  CLRF   xD3
....................   signed int16 temp_ki = 0; 
1DA4:  CLRF   xD4
1DA6:  CLRF   xD5
....................   signed int16 temp_kd = 0; 
1DA8:  CLRF   xD6
1DAA:  CLRF   xD7
....................   signed int16 pw_duty_Right_Temp = 0; 
1DAC:  CLRF   xD8
1DAE:  CLRF   xD9
....................  
....................   e2_r = position_set_Right - position_Right; 
1DB0:  MOVF   x68,W
1DB2:  SUBWF  x74,W
1DB4:  MOVWF  x9C
1DB6:  MOVF   x69,W
1DB8:  SUBWFB x75,W
1DBA:  MOVWF  x9D
1DBC:  MOVF   x6A,W
1DBE:  SUBWFB x76,W
1DC0:  MOVWF  x9E
1DC2:  MOVF   x6B,W
1DC4:  SUBWFB x77,W
1DC6:  MOVWF  x9F
....................   e_sum_r += e2_r; 
1DC8:  MOVF   x9C,W
1DCA:  ADDWF  x90,F
1DCC:  MOVF   x9D,W
1DCE:  ADDWFC x91,F
1DD0:  MOVF   x9E,W
1DD2:  ADDWFC x92,F
1DD4:  MOVF   x9F,W
1DD6:  ADDWFC x93,F
....................   e_del_r = e2_r - e1_r; 
1DD8:  MOVF   x98,W
1DDA:  SUBWF  x9C,W
1DDC:  MOVWF  x94
1DDE:  MOVF   x99,W
1DE0:  SUBWFB x9D,W
1DE2:  MOVWF  x95
1DE4:  MOVF   x9A,W
1DE6:  SUBWFB x9E,W
1DE8:  MOVWF  x96
1DEA:  MOVF   x9B,W
1DEC:  SUBWFB x9F,W
1DEE:  MOVWF  x97
....................   e1_r = e2_r; 
1DF0:  MOVFF  9F,9B
1DF4:  MOVFF  9E,9A
1DF8:  MOVFF  9D,99
1DFC:  MOVFF  9C,98
....................  
....................   temp_kp = (signed int16)((float)kp_r*e2_r); 
1E00:  MOVFF  9F,DD
1E04:  MOVFF  9E,DC
1E08:  MOVFF  9D,DB
1E0C:  MOVFF  9C,DA
1E10:  CALL   15D4
1E14:  CLRF   18
1E16:  BTFSC  FF2.7
1E18:  BSF    18.7
1E1A:  BCF    FF2.7
1E1C:  MOVFF  7B,14A
1E20:  MOVFF  7A,149
1E24:  MOVFF  79,148
1E28:  MOVFF  78,147
1E2C:  MOVFF  03,14E
1E30:  MOVFF  02,14D
1E34:  MOVFF  01,14C
1E38:  MOVFF  00,14B
1E3C:  CALL   01A4
1E40:  BTFSC  18.7
1E42:  BSF    FF2.7
1E44:  MOVFF  03,113
1E48:  MOVFF  02,112
1E4C:  MOVFF  01,111
1E50:  MOVFF  00,110
1E54:  RCALL  16A4
1E56:  MOVFF  02,D3
1E5A:  MOVFF  01,D2
....................   temp_ki = (signed int16)((float)ki_r*e_sum_r); 
1E5E:  MOVFF  93,DD
1E62:  MOVFF  92,DC
1E66:  MOVFF  91,DB
1E6A:  MOVFF  90,DA
1E6E:  CALL   15D4
1E72:  CLRF   18
1E74:  BTFSC  FF2.7
1E76:  BSF    18.7
1E78:  BCF    FF2.7
1E7A:  MOVFF  83,14A
1E7E:  MOVFF  82,149
1E82:  MOVFF  81,148
1E86:  MOVFF  80,147
1E8A:  MOVFF  03,14E
1E8E:  MOVFF  02,14D
1E92:  MOVFF  01,14C
1E96:  MOVFF  00,14B
1E9A:  CALL   01A4
1E9E:  BTFSC  18.7
1EA0:  BSF    FF2.7
1EA2:  MOVFF  03,113
1EA6:  MOVFF  02,112
1EAA:  MOVFF  01,111
1EAE:  MOVFF  00,110
1EB2:  CALL   16A4
1EB6:  MOVFF  02,D5
1EBA:  MOVFF  01,D4
....................   temp_kd = (signed int16)((float)kd_r*e_del_r); 
1EBE:  MOVFF  97,DD
1EC2:  MOVFF  96,DC
1EC6:  MOVFF  95,DB
1ECA:  MOVFF  94,DA
1ECE:  CALL   15D4
1ED2:  CLRF   18
1ED4:  BTFSC  FF2.7
1ED6:  BSF    18.7
1ED8:  BCF    FF2.7
1EDA:  MOVFF  7F,14A
1EDE:  MOVFF  7E,149
1EE2:  MOVFF  7D,148
1EE6:  MOVFF  7C,147
1EEA:  MOVFF  03,14E
1EEE:  MOVFF  02,14D
1EF2:  MOVFF  01,14C
1EF6:  MOVFF  00,14B
1EFA:  CALL   01A4
1EFE:  BTFSC  18.7
1F00:  BSF    FF2.7
1F02:  MOVFF  03,113
1F06:  MOVFF  02,112
1F0A:  MOVFF  01,111
1F0E:  MOVFF  00,110
1F12:  CALL   16A4
1F16:  MOVFF  02,D7
1F1A:  MOVFF  01,D6
....................    
....................   pw_duty_Right_Temp = (signed int16)( temp_kp + temp_ki + temp_kd); 
1F1E:  MOVF   xD4,W
1F20:  ADDWF  xD2,W
1F22:  MOVWF  xDA
1F24:  MOVF   xD5,W
1F26:  ADDWFC xD3,W
1F28:  MOVWF  xDB
1F2A:  MOVF   xD6,W
1F2C:  ADDWF  xDA,W
1F2E:  MOVWF  xD8
1F30:  MOVF   xD7,W
1F32:  ADDWFC xDB,W
1F34:  MOVWF  xD9
....................  
....................   if (pw_duty_Right_Temp > THRES_RIGHT) pw_duty_Right_Temp = THRES_RIGHT; 
1F36:  BTFSC  xD9.7
1F38:  BRA    1F4A
1F3A:  MOVF   xD9,F
1F3C:  BNZ   1F44
1F3E:  MOVF   xD8,W
1F40:  SUBLW  37
1F42:  BC    1F4A
1F44:  CLRF   xD9
1F46:  MOVLW  37
1F48:  MOVWF  xD8
....................   if (pw_duty_Right_Temp < -THRES_RIGHT) pw_duty_Right_Temp = -THRES_RIGHT;  
1F4A:  BTFSS  xD9.7
1F4C:  BRA    1F64
1F4E:  MOVF   xD9,W
1F50:  SUBLW  FF
1F52:  BNC   1F64
1F54:  BNZ   1F5C
1F56:  MOVF   xD8,W
1F58:  SUBLW  C8
1F5A:  BNC   1F64
1F5C:  MOVLW  FF
1F5E:  MOVWF  xD9
1F60:  MOVLW  C9
1F62:  MOVWF  xD8
....................    
....................   if (pw_duty_Right_Temp < 0) 
1F64:  BTFSC  xD9.7
1F66:  BRA    1F6A
1F68:  BRA    1F7C
....................     { 
....................      DIR_RIGHT = 1; 
1F6A:  BSF    F84.1
....................      pw_duty_Right = - pw_duty_Right_Temp; 
1F6C:  COMF   xD8,W
1F6E:  MOVWF  x66
1F70:  COMF   xD9,W
1F72:  MOVWF  x67
1F74:  INCF   x66,F
1F76:  BTFSC  FD8.2
1F78:  INCF   x67,F
....................     } 
....................   else 
1F7A:  BRA    1F86
....................     { 
....................       DIR_RIGHT = 0; 
1F7C:  BCF    F84.1
....................       pw_duty_Right = pw_duty_Right_Temp; 
1F7E:  MOVFF  D9,67
1F82:  MOVFF  D8,66
....................     } 
....................   set_pwm1_duty((int16)pw_duty_Right);  
1F86:  MOVFF  67,02
1F8A:  MOVFF  66,01
1F8E:  RRCF   02,F
1F90:  RRCF   01,F
1F92:  RRCF   02,F
1F94:  RRCF   01,F
1F96:  RRCF   02,F
1F98:  MOVFF  01,FBE
1F9C:  RRCF   02,F
1F9E:  RRCF   02,W
1FA0:  ANDLW  30
1FA2:  MOVWF  00
1FA4:  MOVF   FBD,W
1FA6:  ANDLW  CF
1FA8:  IORWF  00,W
1FAA:  MOVWF  FBD
....................    if(e2_r > -ERR && e2_r < ERR ) 
1FAC:  BTFSS  x9F.7
1FAE:  BRA    1FD4
1FB0:  MOVF   x9F,W
1FB2:  SUBLW  FE
1FB4:  BC    1FEE
1FB6:  XORLW  FF
1FB8:  BNZ   1FD4
1FBA:  MOVF   x9E,W
1FBC:  SUBLW  FE
1FBE:  BC    1FEE
1FC0:  XORLW  FF
1FC2:  BNZ   1FD4
1FC4:  MOVF   x9D,W
1FC6:  SUBLW  FE
1FC8:  BC    1FEE
1FCA:  XORLW  FF
1FCC:  BNZ   1FD4
1FCE:  MOVF   x9C,W
1FD0:  SUBLW  FC
1FD2:  BC    1FEE
1FD4:  BTFSC  x9F.7
1FD6:  BRA    1FEA
1FD8:  MOVF   x9F,F
1FDA:  BNZ   1FEE
1FDC:  MOVF   x9E,F
1FDE:  BNZ   1FEE
1FE0:  MOVF   x9D,F
1FE2:  BNZ   1FEE
1FE4:  MOVF   x9C,W
1FE6:  SUBLW  03
1FE8:  BNC   1FEE
....................    { 
....................       pid_Right_Flag = 0; 
1FEA:  BCF    2F.4
....................    } 
....................    else  
1FEC:  BRA    1FF0
....................     { 
....................       pid_Right_Flag = 1; 
1FEE:  BSF    2F.4
....................     }       
....................  
.................... } 
1FF0:  GOTO   244A (RETURN)
....................  
.................... void pid_Left() 
.................... { 
....................   signed int16 temp_kp = 0; 
1FF4:  CLRF   xD2
1FF6:  CLRF   xD3
....................   signed int16 temp_ki = 0; 
1FF8:  CLRF   xD4
1FFA:  CLRF   xD5
....................   signed int16 temp_kd = 0; 
1FFC:  CLRF   xD6
1FFE:  CLRF   xD7
....................   signed int16 pw_duty_Left_Temp = 0; 
2000:  CLRF   xD8
2002:  CLRF   xD9
....................  
....................   e2_l = position_set_Left - position_Left; 
2004:  MOVF   x6C,W
2006:  SUBWF  x70,W
2008:  MOVWF  xAC
200A:  MOVF   x6D,W
200C:  SUBWFB x71,W
200E:  MOVWF  xAD
2010:  MOVF   x6E,W
2012:  SUBWFB x72,W
2014:  MOVWF  xAE
2016:  MOVF   x6F,W
2018:  SUBWFB x73,W
201A:  MOVWF  xAF
....................   e_sum_l += e2_l; 
201C:  MOVF   xAC,W
201E:  ADDWF  xA0,F
2020:  MOVF   xAD,W
2022:  ADDWFC xA1,F
2024:  MOVF   xAE,W
2026:  ADDWFC xA2,F
2028:  MOVF   xAF,W
202A:  ADDWFC xA3,F
....................   e_del_l = e2_l - e1_l; 
202C:  MOVF   xA8,W
202E:  SUBWF  xAC,W
2030:  MOVWF  xA4
2032:  MOVF   xA9,W
2034:  SUBWFB xAD,W
2036:  MOVWF  xA5
2038:  MOVF   xAA,W
203A:  SUBWFB xAE,W
203C:  MOVWF  xA6
203E:  MOVF   xAB,W
2040:  SUBWFB xAF,W
2042:  MOVWF  xA7
....................   e1_l = e2_l; 
2044:  MOVFF  AF,AB
2048:  MOVFF  AE,AA
204C:  MOVFF  AD,A9
2050:  MOVFF  AC,A8
....................  
....................   temp_kp = (signed int16)((float)kp_l*e2_l); 
2054:  MOVFF  AF,DD
2058:  MOVFF  AE,DC
205C:  MOVFF  AD,DB
2060:  MOVFF  AC,DA
2064:  CALL   15D4
2068:  CLRF   18
206A:  BTFSC  FF2.7
206C:  BSF    18.7
206E:  BCF    FF2.7
2070:  MOVFF  87,14A
2074:  MOVFF  86,149
2078:  MOVFF  85,148
207C:  MOVFF  84,147
2080:  MOVFF  03,14E
2084:  MOVFF  02,14D
2088:  MOVFF  01,14C
208C:  MOVFF  00,14B
2090:  CALL   01A4
2094:  BTFSC  18.7
2096:  BSF    FF2.7
2098:  MOVFF  03,113
209C:  MOVFF  02,112
20A0:  MOVFF  01,111
20A4:  MOVFF  00,110
20A8:  CALL   16A4
20AC:  MOVFF  02,D3
20B0:  MOVFF  01,D2
....................   temp_ki = (signed int16)((float)ki_l*e_sum_l); 
20B4:  MOVFF  A3,DD
20B8:  MOVFF  A2,DC
20BC:  MOVFF  A1,DB
20C0:  MOVFF  A0,DA
20C4:  CALL   15D4
20C8:  CLRF   18
20CA:  BTFSC  FF2.7
20CC:  BSF    18.7
20CE:  BCF    FF2.7
20D0:  MOVFF  8F,14A
20D4:  MOVFF  8E,149
20D8:  MOVFF  8D,148
20DC:  MOVFF  8C,147
20E0:  MOVFF  03,14E
20E4:  MOVFF  02,14D
20E8:  MOVFF  01,14C
20EC:  MOVFF  00,14B
20F0:  CALL   01A4
20F4:  BTFSC  18.7
20F6:  BSF    FF2.7
20F8:  MOVFF  03,113
20FC:  MOVFF  02,112
2100:  MOVFF  01,111
2104:  MOVFF  00,110
2108:  CALL   16A4
210C:  MOVFF  02,D5
2110:  MOVFF  01,D4
....................   temp_kd = (signed int16)((float)kd_l*e_del_l); 
2114:  MOVFF  A7,DD
2118:  MOVFF  A6,DC
211C:  MOVFF  A5,DB
2120:  MOVFF  A4,DA
2124:  CALL   15D4
2128:  CLRF   18
212A:  BTFSC  FF2.7
212C:  BSF    18.7
212E:  BCF    FF2.7
2130:  MOVFF  8B,14A
2134:  MOVFF  8A,149
2138:  MOVFF  89,148
213C:  MOVFF  88,147
2140:  MOVFF  03,14E
2144:  MOVFF  02,14D
2148:  MOVFF  01,14C
214C:  MOVFF  00,14B
2150:  CALL   01A4
2154:  BTFSC  18.7
2156:  BSF    FF2.7
2158:  MOVFF  03,113
215C:  MOVFF  02,112
2160:  MOVFF  01,111
2164:  MOVFF  00,110
2168:  CALL   16A4
216C:  MOVFF  02,D7
2170:  MOVFF  01,D6
....................    
....................   pw_duty_Left_Temp = (signed int16)( temp_kp + temp_ki + temp_kd); 
2174:  MOVF   xD4,W
2176:  ADDWF  xD2,W
2178:  MOVWF  xDA
217A:  MOVF   xD5,W
217C:  ADDWFC xD3,W
217E:  MOVWF  xDB
2180:  MOVF   xD6,W
2182:  ADDWF  xDA,W
2184:  MOVWF  xD8
2186:  MOVF   xD7,W
2188:  ADDWFC xDB,W
218A:  MOVWF  xD9
....................   if (pw_duty_Left_Temp > THRES_LEFT)   pw_duty_Left_Temp = THRES_LEFT; 
218C:  BTFSC  xD9.7
218E:  BRA    21A0
2190:  MOVF   xD9,F
2192:  BNZ   219A
2194:  MOVF   xD8,W
2196:  SUBLW  41
2198:  BC    21A0
219A:  CLRF   xD9
219C:  MOVLW  41
219E:  MOVWF  xD8
....................   if (pw_duty_Left_Temp < -THRES_LEFT)  pw_duty_Left_Temp = -THRES_LEFT;  
21A0:  BTFSS  xD9.7
21A2:  BRA    21BA
21A4:  MOVF   xD9,W
21A6:  SUBLW  FF
21A8:  BNC   21BA
21AA:  BNZ   21B2
21AC:  MOVF   xD8,W
21AE:  SUBLW  BE
21B0:  BNC   21BA
21B2:  MOVLW  FF
21B4:  MOVWF  xD9
21B6:  MOVLW  BF
21B8:  MOVWF  xD8
....................    
....................   if (pw_duty_Left_Temp < 0) 
21BA:  BTFSC  xD9.7
21BC:  BRA    21C0
21BE:  BRA    21D2
....................     { 
....................       DIR_LEFT = 1; 
21C0:  BSF    F84.2
....................       pw_duty_Left = - pw_duty_Left_Temp; 
21C2:  COMF   xD8,W
21C4:  MOVWF  x64
21C6:  COMF   xD9,W
21C8:  MOVWF  x65
21CA:  INCF   x64,F
21CC:  BTFSC  FD8.2
21CE:  INCF   x65,F
....................     } 
....................   else 
21D0:  BRA    21DC
....................     { 
....................       DIR_LEFT = 0; 
21D2:  BCF    F84.2
....................       pw_duty_Left = pw_duty_Left_Temp; 
21D4:  MOVFF  D9,65
21D8:  MOVFF  D8,64
....................     } 
....................    set_pwm2_duty((int16)pw_duty_Left);  
21DC:  MOVFF  65,02
21E0:  MOVFF  64,01
21E4:  RRCF   02,F
21E6:  RRCF   01,F
21E8:  RRCF   02,F
21EA:  RRCF   01,F
21EC:  RRCF   02,F
21EE:  MOVFF  01,FBB
21F2:  RRCF   02,F
21F4:  RRCF   02,W
21F6:  ANDLW  30
21F8:  MOVWF  00
21FA:  MOVF   FBA,W
21FC:  ANDLW  CF
21FE:  IORWF  00,W
2200:  MOVWF  FBA
....................    if(e2_l > -ERR && e2_l < ERR) 
2202:  BTFSS  xAF.7
2204:  BRA    222A
2206:  MOVF   xAF,W
2208:  SUBLW  FE
220A:  BC    2244
220C:  XORLW  FF
220E:  BNZ   222A
2210:  MOVF   xAE,W
2212:  SUBLW  FE
2214:  BC    2244
2216:  XORLW  FF
2218:  BNZ   222A
221A:  MOVF   xAD,W
221C:  SUBLW  FE
221E:  BC    2244
2220:  XORLW  FF
2222:  BNZ   222A
2224:  MOVF   xAC,W
2226:  SUBLW  FC
2228:  BC    2244
222A:  BTFSC  xAF.7
222C:  BRA    2240
222E:  MOVF   xAF,F
2230:  BNZ   2244
2232:  MOVF   xAE,F
2234:  BNZ   2244
2236:  MOVF   xAD,F
2238:  BNZ   2244
223A:  MOVF   xAC,W
223C:  SUBLW  03
223E:  BNC   2244
....................    { 
....................       pid_Left_Flag = 0; 
2240:  BCF    2F.3
....................    } 
....................    else  
2242:  BRA    2246
....................     { 
....................       pid_Left_Flag = 1; 
2244:  BSF    2F.3
....................     } 
.................... } 
2246:  GOTO   244C (RETURN)
....................  
....................  
.................... void moveRobot(char direction, float value) 
.................... { 
....................    if(RobotFlag) 
*
0DAE:  BTFSS  2F.1
0DB0:  GOTO   15D0
....................    { 
....................    init_pid_Right(); 
0DB4:  BRA    0D12
....................    init_pid_Left(); 
0DB6:  BRA    0D60
....................    pid_Left_Flag = 1; 
0DB8:  BSF    2F.3
....................    pid_Right_Flag = 1; 
0DBA:  BSF    2F.4
....................    donePID = 0; 
0DBC:  BCF    2F.5
....................     
....................     num_Pulse_Right = 0; 
0DBE:  CLRF   22
0DC0:  CLRF   21
0DC2:  CLRF   20
0DC4:  CLRF   1F
....................    num_Pulse_Left = 0; 
0DC6:  CLRF   2A
0DC8:  CLRF   29
0DCA:  CLRF   28
0DCC:  CLRF   27
....................    position_Right = 0; 
0DCE:  CLRF   x6B
0DD0:  CLRF   x6A
0DD2:  CLRF   x69
0DD4:  CLRF   x68
....................    position_Left = 0; 
0DD6:  CLRF   x6F
0DD8:  CLRF   x6E
0DDA:  CLRF   x6D
0DDC:  CLRF   x6C
....................    RobotFlag = 0; 
0DDE:  BCF    2F.1
....................    switch(direction) 
....................    { 
0DE0:  MOVF   xD2,W
0DE2:  XORLW  54
0DE4:  BZ    0E00
0DE6:  XORLW  12
0DE8:  BTFSC  FD8.2
0DEA:  BRA    0F3C
0DEC:  XORLW  04
0DEE:  BTFSC  FD8.2
0DF0:  BRA    1068
0DF2:  XORLW  10
0DF4:  BTFSC  FD8.2
0DF6:  BRA    1194
0DF8:  XORLW  1E
0DFA:  BTFSC  FD8.2
0DFC:  BRA    13BA
0DFE:  BRA    15CE
....................      case 'T': 
0E00:  CLRF   18
0E02:  BTFSC  FF2.7
0E04:  BSF    18.7
0E06:  BCF    FF2.7
....................       position_set_Left  = (unsigned int32)(300.0*value/PERIMETER_LEFT); 
0E08:  MOVLB  1
0E0A:  CLRF   x4A
0E0C:  CLRF   x49
0E0E:  MOVLW  16
0E10:  MOVWF  x48
0E12:  MOVLW  87
0E14:  MOVWF  x47
0E16:  MOVFF  D6,14E
0E1A:  MOVFF  D5,14D
0E1E:  MOVFF  D4,14C
0E22:  MOVFF  D3,14B
0E26:  MOVLB  0
0E28:  CALL   01A4
0E2C:  BTFSC  18.7
0E2E:  BSF    FF2.7
0E30:  MOVFF  00,D7
0E34:  MOVFF  01,D8
0E38:  MOVFF  02,D9
0E3C:  MOVFF  03,DA
0E40:  CLRF   18
0E42:  BTFSC  FF2.7
0E44:  BSF    18.7
0E46:  BCF    FF2.7
0E48:  MOVFF  03,14B
0E4C:  MOVFF  02,14A
0E50:  MOVFF  01,149
0E54:  MOVFF  00,148
0E58:  MOVLW  9A
0E5A:  MOVLB  1
0E5C:  MOVWF  x4F
0E5E:  MOVLW  99
0E60:  MOVWF  x4E
0E62:  MOVLW  7F
0E64:  MOVWF  x4D
0E66:  MOVLW  83
0E68:  MOVWF  x4C
0E6A:  MOVLB  0
0E6C:  CALL   0548
0E70:  BTFSC  18.7
0E72:  BSF    FF2.7
0E74:  MOVFF  03,E2
0E78:  MOVFF  02,E1
0E7C:  MOVFF  01,E0
0E80:  MOVFF  00,DF
0E84:  RCALL  0AC2
0E86:  MOVFF  03,73
0E8A:  MOVFF  02,72
0E8E:  MOVFF  01,71
0E92:  MOVFF  00,70
0E96:  CLRF   18
0E98:  BTFSC  FF2.7
0E9A:  BSF    18.7
0E9C:  BCF    FF2.7
....................       position_set_Right = (unsigned int32)(300.0*value/PERIMETER_RIGHT);    
0E9E:  MOVLB  1
0EA0:  CLRF   x4A
0EA2:  CLRF   x49
0EA4:  MOVLW  16
0EA6:  MOVWF  x48
0EA8:  MOVLW  87
0EAA:  MOVWF  x47
0EAC:  MOVFF  D6,14E
0EB0:  MOVFF  D5,14D
0EB4:  MOVFF  D4,14C
0EB8:  MOVFF  D3,14B
0EBC:  MOVLB  0
0EBE:  CALL   01A4
0EC2:  BTFSC  18.7
0EC4:  BSF    FF2.7
0EC6:  MOVFF  00,D7
0ECA:  MOVFF  01,D8
0ECE:  MOVFF  02,D9
0ED2:  MOVFF  03,DA
0ED6:  CLRF   18
0ED8:  BTFSC  FF2.7
0EDA:  BSF    18.7
0EDC:  BCF    FF2.7
0EDE:  MOVFF  03,14B
0EE2:  MOVFF  02,14A
0EE6:  MOVFF  01,149
0EEA:  MOVFF  00,148
0EEE:  MOVLW  33
0EF0:  MOVLB  1
0EF2:  MOVWF  x4F
0EF4:  MOVWF  x4E
0EF6:  MOVLW  7F
0EF8:  MOVWF  x4D
0EFA:  MOVLW  83
0EFC:  MOVWF  x4C
0EFE:  MOVLB  0
0F00:  CALL   0548
0F04:  BTFSC  18.7
0F06:  BSF    FF2.7
0F08:  MOVFF  03,E2
0F0C:  MOVFF  02,E1
0F10:  MOVFF  01,E0
0F14:  MOVFF  00,DF
0F18:  RCALL  0AC2
0F1A:  MOVFF  03,77
0F1E:  MOVFF  02,76
0F22:  MOVFF  01,75
0F26:  MOVFF  00,74
....................       distance_move = 0; 
0F2A:  CLRF   xBF
0F2C:  CLRF   xBE
0F2E:  CLRF   xBD
0F30:  CLRF   xBC
....................       count_left = 0; 
0F32:  CLRF   26
0F34:  CLRF   25
0F36:  CLRF   24
0F38:  CLRF   23
....................  
....................       break;       
0F3A:  BRA    15D0
....................       case 'F': 
0F3C:  CLRF   18
0F3E:  BTFSC  FF2.7
0F40:  BSF    18.7
0F42:  BCF    FF2.7
....................         position_set_Left  = (unsigned int32)(300.0*value/PERIMETER_LEFT); 
0F44:  MOVLB  1
0F46:  CLRF   x4A
0F48:  CLRF   x49
0F4A:  MOVLW  16
0F4C:  MOVWF  x48
0F4E:  MOVLW  87
0F50:  MOVWF  x47
0F52:  MOVFF  D6,14E
0F56:  MOVFF  D5,14D
0F5A:  MOVFF  D4,14C
0F5E:  MOVFF  D3,14B
0F62:  MOVLB  0
0F64:  CALL   01A4
0F68:  BTFSC  18.7
0F6A:  BSF    FF2.7
0F6C:  MOVFF  00,D7
0F70:  MOVFF  01,D8
0F74:  MOVFF  02,D9
0F78:  MOVFF  03,DA
0F7C:  CLRF   18
0F7E:  BTFSC  FF2.7
0F80:  BSF    18.7
0F82:  BCF    FF2.7
0F84:  MOVFF  03,14B
0F88:  MOVFF  02,14A
0F8C:  MOVFF  01,149
0F90:  MOVFF  00,148
0F94:  MOVLW  9A
0F96:  MOVLB  1
0F98:  MOVWF  x4F
0F9A:  MOVLW  99
0F9C:  MOVWF  x4E
0F9E:  MOVLW  7F
0FA0:  MOVWF  x4D
0FA2:  MOVLW  83
0FA4:  MOVWF  x4C
0FA6:  MOVLB  0
0FA8:  CALL   0548
0FAC:  BTFSC  18.7
0FAE:  BSF    FF2.7
0FB0:  MOVFF  03,E2
0FB4:  MOVFF  02,E1
0FB8:  MOVFF  01,E0
0FBC:  MOVFF  00,DF
0FC0:  RCALL  0AC2
0FC2:  MOVFF  03,73
0FC6:  MOVFF  02,72
0FCA:  MOVFF  01,71
0FCE:  MOVFF  00,70
0FD2:  CLRF   18
0FD4:  BTFSC  FF2.7
0FD6:  BSF    18.7
0FD8:  BCF    FF2.7
....................         position_set_Right = (unsigned int32)(300.0*value/PERIMETER_RIGHT);     
0FDA:  MOVLB  1
0FDC:  CLRF   x4A
0FDE:  CLRF   x49
0FE0:  MOVLW  16
0FE2:  MOVWF  x48
0FE4:  MOVLW  87
0FE6:  MOVWF  x47
0FE8:  MOVFF  D6,14E
0FEC:  MOVFF  D5,14D
0FF0:  MOVFF  D4,14C
0FF4:  MOVFF  D3,14B
0FF8:  MOVLB  0
0FFA:  CALL   01A4
0FFE:  BTFSC  18.7
1000:  BSF    FF2.7
1002:  MOVFF  00,D7
1006:  MOVFF  01,D8
100A:  MOVFF  02,D9
100E:  MOVFF  03,DA
1012:  CLRF   18
1014:  BTFSC  FF2.7
1016:  BSF    18.7
1018:  BCF    FF2.7
101A:  MOVFF  03,14B
101E:  MOVFF  02,14A
1022:  MOVFF  01,149
1026:  MOVFF  00,148
102A:  MOVLW  33
102C:  MOVLB  1
102E:  MOVWF  x4F
1030:  MOVWF  x4E
1032:  MOVLW  7F
1034:  MOVWF  x4D
1036:  MOVLW  83
1038:  MOVWF  x4C
103A:  MOVLB  0
103C:  CALL   0548
1040:  BTFSC  18.7
1042:  BSF    FF2.7
1044:  MOVFF  03,E2
1048:  MOVFF  02,E1
104C:  MOVFF  01,E0
1050:  MOVFF  00,DF
1054:  RCALL  0AC2
1056:  MOVFF  03,77
105A:  MOVFF  02,76
105E:  MOVFF  01,75
1062:  MOVFF  00,74
....................         break; 
1066:  BRA    15D0
....................       case  'B': 
1068:  CLRF   18
106A:  BTFSC  FF2.7
106C:  BSF    18.7
106E:  BCF    FF2.7
....................         position_set_Left  =  (unsigned int32)(-300.0*value/PERIMETER_LEFT); 
1070:  MOVLB  1
1072:  CLRF   x4A
1074:  CLRF   x49
1076:  MOVLW  96
1078:  MOVWF  x48
107A:  MOVLW  87
107C:  MOVWF  x47
107E:  MOVFF  D6,14E
1082:  MOVFF  D5,14D
1086:  MOVFF  D4,14C
108A:  MOVFF  D3,14B
108E:  MOVLB  0
1090:  CALL   01A4
1094:  BTFSC  18.7
1096:  BSF    FF2.7
1098:  MOVFF  00,D7
109C:  MOVFF  01,D8
10A0:  MOVFF  02,D9
10A4:  MOVFF  03,DA
10A8:  CLRF   18
10AA:  BTFSC  FF2.7
10AC:  BSF    18.7
10AE:  BCF    FF2.7
10B0:  MOVFF  03,14B
10B4:  MOVFF  02,14A
10B8:  MOVFF  01,149
10BC:  MOVFF  00,148
10C0:  MOVLW  9A
10C2:  MOVLB  1
10C4:  MOVWF  x4F
10C6:  MOVLW  99
10C8:  MOVWF  x4E
10CA:  MOVLW  7F
10CC:  MOVWF  x4D
10CE:  MOVLW  83
10D0:  MOVWF  x4C
10D2:  MOVLB  0
10D4:  CALL   0548
10D8:  BTFSC  18.7
10DA:  BSF    FF2.7
10DC:  MOVFF  03,E2
10E0:  MOVFF  02,E1
10E4:  MOVFF  01,E0
10E8:  MOVFF  00,DF
10EC:  RCALL  0AC2
10EE:  MOVFF  03,73
10F2:  MOVFF  02,72
10F6:  MOVFF  01,71
10FA:  MOVFF  00,70
10FE:  CLRF   18
1100:  BTFSC  FF2.7
1102:  BSF    18.7
1104:  BCF    FF2.7
....................         position_set_Right =  (unsigned int32)(-300.0*value/PERIMETER_RIGHT); 
1106:  MOVLB  1
1108:  CLRF   x4A
110A:  CLRF   x49
110C:  MOVLW  96
110E:  MOVWF  x48
1110:  MOVLW  87
1112:  MOVWF  x47
1114:  MOVFF  D6,14E
1118:  MOVFF  D5,14D
111C:  MOVFF  D4,14C
1120:  MOVFF  D3,14B
1124:  MOVLB  0
1126:  CALL   01A4
112A:  BTFSC  18.7
112C:  BSF    FF2.7
112E:  MOVFF  00,D7
1132:  MOVFF  01,D8
1136:  MOVFF  02,D9
113A:  MOVFF  03,DA
113E:  CLRF   18
1140:  BTFSC  FF2.7
1142:  BSF    18.7
1144:  BCF    FF2.7
1146:  MOVFF  03,14B
114A:  MOVFF  02,14A
114E:  MOVFF  01,149
1152:  MOVFF  00,148
1156:  MOVLW  33
1158:  MOVLB  1
115A:  MOVWF  x4F
115C:  MOVWF  x4E
115E:  MOVLW  7F
1160:  MOVWF  x4D
1162:  MOVLW  83
1164:  MOVWF  x4C
1166:  MOVLB  0
1168:  CALL   0548
116C:  BTFSC  18.7
116E:  BSF    FF2.7
1170:  MOVFF  03,E2
1174:  MOVFF  02,E1
1178:  MOVFF  01,E0
117C:  MOVFF  00,DF
1180:  RCALL  0AC2
1182:  MOVFF  03,77
1186:  MOVFF  02,76
118A:  MOVFF  01,75
118E:  MOVFF  00,74
....................         break; 
1192:  BRA    15D0
....................       case 'R': 
....................         anpha = - value*PI/180.0; 
1194:  MOVFF  D3,D7
1198:  MOVF   xD4,W
119A:  XORLW  80
119C:  MOVWF  xD8
119E:  MOVFF  D5,D9
11A2:  MOVFF  D6,DA
11A6:  CLRF   18
11A8:  BTFSC  FF2.7
11AA:  BSF    18.7
11AC:  BCF    FF2.7
11AE:  MOVFF  D6,14A
11B2:  MOVFF  D5,149
11B6:  MOVFF  FE8,148
11BA:  MOVFF  D3,147
11BE:  MOVLW  DB
11C0:  MOVLB  1
11C2:  MOVWF  x4E
11C4:  MOVLW  0F
11C6:  MOVWF  x4D
11C8:  MOVLW  49
11CA:  MOVWF  x4C
11CC:  MOVLW  80
11CE:  MOVWF  x4B
11D0:  MOVLB  0
11D2:  CALL   01A4
11D6:  BTFSC  18.7
11D8:  BSF    FF2.7
11DA:  MOVFF  00,DB
11DE:  MOVFF  01,DC
11E2:  MOVFF  02,DD
11E6:  MOVFF  03,DE
11EA:  CLRF   18
11EC:  BTFSC  FF2.7
11EE:  BSF    18.7
11F0:  BCF    FF2.7
11F2:  MOVFF  03,14B
11F6:  MOVFF  02,14A
11FA:  MOVFF  01,149
11FE:  MOVFF  00,148
1202:  MOVLB  1
1204:  CLRF   x4F
1206:  CLRF   x4E
1208:  MOVLW  34
120A:  MOVWF  x4D
120C:  MOVLW  86
120E:  MOVWF  x4C
1210:  MOVLB  0
1212:  CALL   0548
1216:  BTFSC  18.7
1218:  BSF    FF2.7
121A:  MOVFF  03,B7
121E:  MOVFF  02,B6
1222:  MOVFF  01,B5
1226:  MOVFF  00,B4
122A:  CLRF   18
122C:  BTFSC  FF2.7
122E:  BSF    18.7
1230:  BCF    FF2.7
....................         position_set_Left  =  (unsigned int32)(-300.0*(anpha*RADIUS)/PERIMETER_LEFT); 
1232:  MOVFF  B7,14A
1236:  MOVFF  B6,149
123A:  MOVFF  B5,148
123E:  MOVFF  B4,147
1242:  MOVLB  1
1244:  CLRF   x4E
1246:  CLRF   x4D
1248:  MOVLW  22
124A:  MOVWF  x4C
124C:  MOVLW  83
124E:  MOVWF  x4B
1250:  MOVLB  0
1252:  CALL   01A4
1256:  BTFSC  18.7
1258:  BSF    FF2.7
125A:  CLRF   18
125C:  BTFSC  FF2.7
125E:  BSF    18.7
1260:  BCF    FF2.7
1262:  MOVLB  1
1264:  CLRF   x4A
1266:  CLRF   x49
1268:  MOVLW  96
126A:  MOVWF  x48
126C:  MOVLW  87
126E:  MOVWF  x47
1270:  MOVFF  03,14E
1274:  MOVFF  02,14D
1278:  MOVFF  01,14C
127C:  MOVFF  00,14B
1280:  MOVLB  0
1282:  CALL   01A4
1286:  BTFSC  18.7
1288:  BSF    FF2.7
128A:  MOVFF  00,D7
128E:  MOVFF  01,D8
1292:  MOVFF  02,D9
1296:  MOVFF  03,DA
129A:  CLRF   18
129C:  BTFSC  FF2.7
129E:  BSF    18.7
12A0:  BCF    FF2.7
12A2:  MOVFF  03,14B
12A6:  MOVFF  02,14A
12AA:  MOVFF  01,149
12AE:  MOVFF  00,148
12B2:  MOVLW  9A
12B4:  MOVLB  1
12B6:  MOVWF  x4F
12B8:  MOVLW  99
12BA:  MOVWF  x4E
12BC:  MOVLW  7F
12BE:  MOVWF  x4D
12C0:  MOVLW  83
12C2:  MOVWF  x4C
12C4:  MOVLB  0
12C6:  CALL   0548
12CA:  BTFSC  18.7
12CC:  BSF    FF2.7
12CE:  MOVFF  03,E2
12D2:  MOVFF  02,E1
12D6:  MOVFF  01,E0
12DA:  MOVFF  00,DF
12DE:  CALL   0AC2
12E2:  MOVFF  03,73
12E6:  MOVFF  02,72
12EA:  MOVFF  01,71
12EE:  MOVFF  00,70
12F2:  CLRF   18
12F4:  BTFSC  FF2.7
12F6:  BSF    18.7
12F8:  BCF    FF2.7
....................         position_set_Right =  (unsigned int32)(300.0*(anpha*RADIUS)/PERIMETER_RIGHT);     
12FA:  MOVFF  B7,14A
12FE:  MOVFF  B6,149
1302:  MOVFF  B5,148
1306:  MOVFF  B4,147
130A:  MOVLB  1
130C:  CLRF   x4E
130E:  CLRF   x4D
1310:  MOVLW  22
1312:  MOVWF  x4C
1314:  MOVLW  83
1316:  MOVWF  x4B
1318:  MOVLB  0
131A:  CALL   01A4
131E:  BTFSC  18.7
1320:  BSF    FF2.7
1322:  CLRF   18
1324:  BTFSC  FF2.7
1326:  BSF    18.7
1328:  BCF    FF2.7
132A:  MOVLB  1
132C:  CLRF   x4A
132E:  CLRF   x49
1330:  MOVLW  16
1332:  MOVWF  x48
1334:  MOVLW  87
1336:  MOVWF  x47
1338:  MOVFF  03,14E
133C:  MOVFF  02,14D
1340:  MOVFF  01,14C
1344:  MOVFF  00,14B
1348:  MOVLB  0
134A:  CALL   01A4
134E:  BTFSC  18.7
1350:  BSF    FF2.7
1352:  MOVFF  00,D7
1356:  MOVFF  01,D8
135A:  MOVFF  02,D9
135E:  MOVFF  03,DA
1362:  CLRF   18
1364:  BTFSC  FF2.7
1366:  BSF    18.7
1368:  BCF    FF2.7
136A:  MOVFF  03,14B
136E:  MOVFF  02,14A
1372:  MOVFF  01,149
1376:  MOVFF  00,148
137A:  MOVLW  33
137C:  MOVLB  1
137E:  MOVWF  x4F
1380:  MOVWF  x4E
1382:  MOVLW  7F
1384:  MOVWF  x4D
1386:  MOVLW  83
1388:  MOVWF  x4C
138A:  MOVLB  0
138C:  CALL   0548
1390:  BTFSC  18.7
1392:  BSF    FF2.7
1394:  MOVFF  03,E2
1398:  MOVFF  02,E1
139C:  MOVFF  01,E0
13A0:  MOVFF  00,DF
13A4:  CALL   0AC2
13A8:  MOVFF  03,77
13AC:  MOVFF  02,76
13B0:  MOVFF  01,75
13B4:  MOVFF  00,74
....................         break; 
13B8:  BRA    15D0
....................       case 'L': 
13BA:  CLRF   18
13BC:  BTFSC  FF2.7
13BE:  BSF    18.7
13C0:  BCF    FF2.7
....................         anpha = value*PI/180.0;      
13C2:  MOVFF  D6,14A
13C6:  MOVFF  D5,149
13CA:  MOVFF  D4,148
13CE:  MOVFF  D3,147
13D2:  MOVLW  DB
13D4:  MOVLB  1
13D6:  MOVWF  x4E
13D8:  MOVLW  0F
13DA:  MOVWF  x4D
13DC:  MOVLW  49
13DE:  MOVWF  x4C
13E0:  MOVLW  80
13E2:  MOVWF  x4B
13E4:  MOVLB  0
13E6:  CALL   01A4
13EA:  BTFSC  18.7
13EC:  BSF    FF2.7
13EE:  MOVFF  00,D7
13F2:  MOVFF  01,D8
13F6:  MOVFF  02,D9
13FA:  MOVFF  03,DA
13FE:  CLRF   18
1400:  BTFSC  FF2.7
1402:  BSF    18.7
1404:  BCF    FF2.7
1406:  MOVFF  03,14B
140A:  MOVFF  02,14A
140E:  MOVFF  01,149
1412:  MOVFF  00,148
1416:  MOVLB  1
1418:  CLRF   x4F
141A:  CLRF   x4E
141C:  MOVLW  34
141E:  MOVWF  x4D
1420:  MOVLW  86
1422:  MOVWF  x4C
1424:  MOVLB  0
1426:  CALL   0548
142A:  BTFSC  18.7
142C:  BSF    FF2.7
142E:  MOVFF  03,B7
1432:  MOVFF  02,B6
1436:  MOVFF  01,B5
143A:  MOVFF  00,B4
143E:  CLRF   18
1440:  BTFSC  FF2.7
1442:  BSF    18.7
1444:  BCF    FF2.7
....................         position_set_Left  =  (unsigned int32)(-300.0*(anpha*RADIUS)/PERIMETER_LEFT); 
1446:  MOVFF  B7,14A
144A:  MOVFF  B6,149
144E:  MOVFF  B5,148
1452:  MOVFF  B4,147
1456:  MOVLB  1
1458:  CLRF   x4E
145A:  CLRF   x4D
145C:  MOVLW  22
145E:  MOVWF  x4C
1460:  MOVLW  83
1462:  MOVWF  x4B
1464:  MOVLB  0
1466:  CALL   01A4
146A:  BTFSC  18.7
146C:  BSF    FF2.7
146E:  CLRF   18
1470:  BTFSC  FF2.7
1472:  BSF    18.7
1474:  BCF    FF2.7
1476:  MOVLB  1
1478:  CLRF   x4A
147A:  CLRF   x49
147C:  MOVLW  96
147E:  MOVWF  x48
1480:  MOVLW  87
1482:  MOVWF  x47
1484:  MOVFF  03,14E
1488:  MOVFF  02,14D
148C:  MOVFF  01,14C
1490:  MOVFF  00,14B
1494:  MOVLB  0
1496:  CALL   01A4
149A:  BTFSC  18.7
149C:  BSF    FF2.7
149E:  MOVFF  00,D7
14A2:  MOVFF  01,D8
14A6:  MOVFF  02,D9
14AA:  MOVFF  03,DA
14AE:  CLRF   18
14B0:  BTFSC  FF2.7
14B2:  BSF    18.7
14B4:  BCF    FF2.7
14B6:  MOVFF  03,14B
14BA:  MOVFF  02,14A
14BE:  MOVFF  01,149
14C2:  MOVFF  00,148
14C6:  MOVLW  9A
14C8:  MOVLB  1
14CA:  MOVWF  x4F
14CC:  MOVLW  99
14CE:  MOVWF  x4E
14D0:  MOVLW  7F
14D2:  MOVWF  x4D
14D4:  MOVLW  83
14D6:  MOVWF  x4C
14D8:  MOVLB  0
14DA:  CALL   0548
14DE:  BTFSC  18.7
14E0:  BSF    FF2.7
14E2:  MOVFF  03,E2
14E6:  MOVFF  02,E1
14EA:  MOVFF  01,E0
14EE:  MOVFF  00,DF
14F2:  CALL   0AC2
14F6:  MOVFF  03,73
14FA:  MOVFF  02,72
14FE:  MOVFF  01,71
1502:  MOVFF  00,70
1506:  CLRF   18
1508:  BTFSC  FF2.7
150A:  BSF    18.7
150C:  BCF    FF2.7
....................         position_set_Right =  (unsigned int32)(300.0*(anpha*RADIUS)/PERIMETER_RIGHT); 
150E:  MOVFF  B7,14A
1512:  MOVFF  B6,149
1516:  MOVFF  B5,148
151A:  MOVFF  B4,147
151E:  MOVLB  1
1520:  CLRF   x4E
1522:  CLRF   x4D
1524:  MOVLW  22
1526:  MOVWF  x4C
1528:  MOVLW  83
152A:  MOVWF  x4B
152C:  MOVLB  0
152E:  CALL   01A4
1532:  BTFSC  18.7
1534:  BSF    FF2.7
1536:  CLRF   18
1538:  BTFSC  FF2.7
153A:  BSF    18.7
153C:  BCF    FF2.7
153E:  MOVLB  1
1540:  CLRF   x4A
1542:  CLRF   x49
1544:  MOVLW  16
1546:  MOVWF  x48
1548:  MOVLW  87
154A:  MOVWF  x47
154C:  MOVFF  03,14E
1550:  MOVFF  02,14D
1554:  MOVFF  01,14C
1558:  MOVFF  00,14B
155C:  MOVLB  0
155E:  CALL   01A4
1562:  BTFSC  18.7
1564:  BSF    FF2.7
1566:  MOVFF  00,D7
156A:  MOVFF  01,D8
156E:  MOVFF  02,D9
1572:  MOVFF  03,DA
1576:  CLRF   18
1578:  BTFSC  FF2.7
157A:  BSF    18.7
157C:  BCF    FF2.7
157E:  MOVFF  03,14B
1582:  MOVFF  02,14A
1586:  MOVFF  01,149
158A:  MOVFF  00,148
158E:  MOVLW  33
1590:  MOVLB  1
1592:  MOVWF  x4F
1594:  MOVWF  x4E
1596:  MOVLW  7F
1598:  MOVWF  x4D
159A:  MOVLW  83
159C:  MOVWF  x4C
159E:  MOVLB  0
15A0:  CALL   0548
15A4:  BTFSC  18.7
15A6:  BSF    FF2.7
15A8:  MOVFF  03,E2
15AC:  MOVFF  02,E1
15B0:  MOVFF  01,E0
15B4:  MOVFF  00,DF
15B8:  CALL   0AC2
15BC:  MOVFF  03,77
15C0:  MOVFF  02,76
15C4:  MOVFF  01,75
15C8:  MOVFF  00,74
....................         break;          
15CC:  BRA    15D0
....................       default:  break; 
15CE:  BRA    15D0
....................    } 
....................    }  
.................... } 
15D0:  GOTO   291C (RETURN)

Configuration Fuses:
   Word  1: 0C20   NOIESO NOFCMEN HS PLL1 CPUDIV1 USBDIV
   Word  2: 1E19   NOBROWNOUT NOWDT BORV20 NOPUT WDT32768 NOVREGEN RESERVED
   Word  3: 8300   PBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
